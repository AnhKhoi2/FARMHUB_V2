// Script: inspectNotebook.js
// Usage: node scripts/inspectNotebook.js [notebookId]

import mongoose from "mongoose";
import dotenv from "dotenv";
import Notebook from "../models/Notebook.js";
import PlantTemplate from "../models/PlantTemplate.js";
import {
  toVietnamMidnight,
  getVietnamToday,
  formatVietnamDate,
} from "../utils/timezone.js";
import { generateDailyChecklist } from "../controllers/notebookController.js";
// do not import dbConfig to avoid default export issues; use MONGODB_URI env var or config/db.js export values if needed

// Load env from backend/.env if exists
dotenv.config({ path: process.env.BACKEND_ENV_PATH || ".env" });

const run = async () => {
  try {
    // connect using config file if it exports connection string/logic
    // Check if config/db.js exports a function or URI
    let mongoUri =
      process.env.MONGODB_URI ||
      process.env.MONGO_URI ||
      process.env.DB_URI ||
      process.env.MONGODB_CONNECTIONSTRING ||
      process.env.MONGODB_CONNECTION_STRING;

    // If db.js exports a function to connect, just call it
    let connected = false;
    try {
      if (typeof dbConfig === "function") {
        await dbConfig();
        connected = true;
      } else if (dbConfig && dbConfig.mongoURI) {
        mongoUri = mongoUri || dbConfig.mongoURI;
      }
    } catch (e) {
      // ignore
    }

    if (!connected) {
      if (!mongoUri) {
        console.error(
          "No MongoDB URI found in environment or config/db.js. Set MONGODB_URI env var."
        );
        process.exit(1);
      }
      await mongoose.connect(mongoUri, {
        useNewUrlParser: true,
        useUnifiedTopology: true,
      });
    }

    const argId = process.argv[2];
    const applyFlag = process.argv[3] === "apply";
    let notebook;
    if (argId) {
      notebook = await Notebook.findById(argId).populate("template_id");
      if (!notebook) {
        console.error("Notebook not found for id", argId);
        process.exit(1);
      }
    } else {
      notebook = await Notebook.findOne({
        current_stage: 2,
        status: { $ne: "deleted" },
      }).populate("template_id");
      if (!notebook) {
        console.error("No notebook found with current_stage=2");
        process.exit(1);
      }
    }

    console.log("=== Notebook basic ===");
    console.log("id:", notebook._id.toString());
    console.log("notebook_name:", notebook.notebook_name);
    console.log("planted_date:", notebook.planted_date);
    console.log("current_day:", notebook.current_day);
    console.log("current_stage:", notebook.current_stage);
    console.log("last_checklist_generated:", notebook.last_checklist_generated);
    console.log(
      "daily_checklist length:",
      (notebook.daily_checklist || []).length
    );

    console.log("\n=== Template summary ===");
    if (notebook.template_id) {
      console.log("template id:", notebook.template_id._id.toString());
      console.log(
        "template name:",
        notebook.template_id.template_name || notebook.template_id.template_name
      );
      console.log("template total_days:", notebook.template_id.total_days);
      console.log("template stages:");
      notebook.template_id.stages.forEach((s) => {
        console.log(
          `  stage ${s.stage_number}: ${s.name} (${s.day_start}-${
            s.day_end
          }) tasks:${(s.autogenerated_tasks || s.daily_tasks || []).length}`
        );
        if (s.stage_number === notebook.current_stage) {
          const tasks = s.autogenerated_tasks || s.daily_tasks || [];
          console.log("    current template stage tasks:");
          tasks.forEach((t, idx) =>
            console.log(
              `      ${idx + 1}. ${t.task_name} | freq=${t.frequency} | desc=${
                t.description || ""
              }`
            )
          );
        }
      });
    } else {
      console.log("No template assigned");
    }

    console.log("\n=== Stages tracking persisted ===");
    notebook.stages_tracking.forEach((st) => {
      console.log(
        `stage ${st.stage_number}: name=${st.stage_name} is_current=${st.is_current} status=${st.status}`
      );
      console.log(
        "  started_at:",
        st.started_at ? st.started_at.toISOString() : null
      );
      console.log(
        "  completed_at:",
        st.completed_at ? st.completed_at.toISOString() : null
      );
      console.log(
        "  completed_tasks.length:",
        (st.completed_tasks || []).length
      );
      (st.completed_tasks || []).forEach((ct, i) => {
        console.log(
          `    completed_task ${i + 1}: ${ct.task_name} at ${ct.completed_at}`
        );
      });
      console.log("  overdue_tasks.length:", (st.overdue_tasks || []).length);
      (st.overdue_tasks || []).forEach((ot, i) => {
        console.log(
          `    overdue_task ${i + 1}: ${ot.task_name} status=${
            ot.status
          } original_date=${ot.original_date}`
        );
      });
      console.log(
        "  daily_logs:",
        (st.daily_logs || []).map((l) => ({
          date: l.date?.toISOString().split("T")[0],
          progress: l.daily_progress,
        }))
      );
    });

    console.log("\n=== Daily checklist (persisted) ===");
    (notebook.daily_checklist || []).forEach((t, i) => {
      console.log(
        `  ${i + 1}. ${t.task_name} | freq=${t.frequency} | completed=${
          t.is_completed
        } | status=${t.status} | created_at=${
          t.created_at || t.createdAt || "n/a"
        }`
      );
    });

    // Also print what generateDailyChecklist would produce now (dry-run)
    console.log("\n=== Dry-run generateDailyChecklist logic ===");
    const today = getVietnamToday();
    console.log("today (VN day-start):", today.toISOString());

    // compute daysInStage using started_at if present
    const currentStage = notebook.template_id
      ? notebook.template_id.stages.find(
          (s) => s.stage_number === notebook.current_stage
        )
      : null;
    const currentStageTracking = notebook.stages_tracking.find(
      (s) => s.stage_number === notebook.current_stage
    );
    let daysInStage = null;
    if (currentStageTracking && currentStageTracking.started_at) {
      daysInStage =
        Math.floor(
          (toVietnamMidnight(today) -
            toVietnamMidnight(currentStageTracking.started_at)) /
            (1000 * 60 * 60 * 24)
        ) + 1;
    } else if (notebook.current_day && currentStage) {
      daysInStage =
        Math.floor(notebook.current_day) - currentStage.day_start + 1;
    }
    console.log("computed daysInStage:", daysInStage);

    if (currentStage) {
      const tasks = (
        currentStage.autogenerated_tasks ||
        currentStage.daily_tasks ||
        []
      ).filter((task) => {
        if (task.frequency === "daily") return true;
        if (task.frequency === "once") {
          const alreadyCompleted = currentStageTracking?.completed_tasks?.some(
            (t) => t.task_name === task.task_name
          );
          return !alreadyCompleted && daysInStage === 1;
        }
        const intervalMap = { every_2_days: 2, every_3_days: 3, weekly: 7 };
        const interval = intervalMap[task.frequency];
        if (!interval) return false;
        const lastCompleted = currentStageTracking?.completed_tasks
          ?.filter((t) => t.task_name === task.task_name)
          .reduce((latest, t) => {
            if (!latest) return t;
            return new Date(t.completed_at) > new Date(latest.completed_at)
              ? t
              : latest;
          }, null);
        if (lastCompleted && lastCompleted.completed_at) {
          const diffDays = Math.floor(
            (toVietnamMidnight(today) -
              toVietnamMidnight(lastCompleted.completed_at)) /
              (1000 * 60 * 60 * 24)
          );
          return diffDays >= interval && diffDays % interval === 0;
        }
        return daysInStage % interval === 0;
      });

      console.log("dry-run tasks to show today (count):", tasks.length);
      tasks.forEach((t, i) =>
        console.log(`  ${i + 1}. ${t.task_name} | freq=${t.frequency}`)
      );
    }

    // If apply flag provided, update started_at of current stage to today and regenerate checklist
    if (applyFlag) {
      console.log(
        "\n=== Applying fix: set current stage started_at = today and regenerate checklist ==="
      );
      const currentStageTracking = notebook.stages_tracking.find(
        (s) => s.stage_number === notebook.current_stage
      );
      if (!currentStageTracking) {
        console.error("No stage tracking found for current stage");
        await mongoose.disconnect();
        process.exit(1);
      }
      currentStageTracking.started_at = getVietnamToday();
      // Reset daily checklist and last generated so generation will run
      notebook.daily_checklist = [];
      notebook.last_checklist_generated = null;
      await notebook.save();

      // Call generateDailyChecklist to populate today's checklist
      try {
        const newChecklist = await generateDailyChecklist(notebook._id);
        console.log(
          "New checklist generated (count):",
          (newChecklist || []).length
        );
        (newChecklist || []).forEach((t, i) =>
          console.log(`  ${i + 1}. ${t.task_name} | freq=${t.frequency}`)
        );
      } catch (e) {
        console.error("Error generating checklist:", e);
      }
    }

    await mongoose.disconnect();
    process.exit(0);
  } catch (err) {
    console.error("Error:", err);
    try {
      await mongoose.disconnect();
    } catch (e) {}
    process.exit(1);
  }
};

run();
