/*
  Test script: test_observation_blocking_flow.js
  Purpose: simulate the flow described by the user:
    - Create a notebook with planted_date = 2025-11-24 (VN timezone assumed)
    - Do NOT complete tasks on day 1
    - Simulate next day (2025-11-25) by regenerating checklist -> tasks from day 1 become overdue
    - Attempt to update observation on day 25 -> should be blocked because overdue + today's tasks not completed
    - Complete overdue + today's tasks
    - Update observation -> should succeed and mark pending_transition
    - Simulate next day and run generateDailyChecklist -> should auto-transition to next stage

  NOTES:
  - This script runs directly against the running backend or local mongo via models.
  - Make sure MongoDB and app dependencies are available. Run with `node` in the backend folder.
*/

import mongoose from "mongoose";
import dotenv from "dotenv";
import Notebook from "../../models/Notebook.js";
import PlantTemplate from "../../models/PlantTemplate.js";
import User from "../../models/User.js";
import {
  parseVietnamDate,
  toVietnamMidnight,
  getVietnamToday,
} from "../../utils/timezone.js";
import {
  generateDailyChecklist,
  updateStageObservation,
  checkNotebookStageStatus,
} from "../../controllers/notebookController.js";

dotenv.config();

const log = (...args) => console.log(new Date().toISOString(), ...args);

async function main() {
  try {
    // Prefer project env var `MONGODB_CONNECTIONSTRING` (from backend/.env)
    const mongoUrl =
      process.env.MONGODB_CONNECTIONSTRING ||
      process.env.MONGO_URI ||
      "mongodb://127.0.0.1:27017/farmhub_v2";

    // Log connection host only (mask credentials)
    try {
      const urlHost = new URL(mongoUrl.replace("mongodb+srv://", "http://"));
      log("Attempting MongoDB connection to:", urlHost.host);
    } catch (e) {
      log("Attempting MongoDB connection (host masked)");
    }

    // Connect without deprecated options (Driver v4+ ignores them)
    await mongoose.connect(mongoUrl);
    log("Connected to MongoDB");

    // 1) Ensure we have a user for ownership (create or reuse)
    let user = await User.findOne({
      email: "test_observation_flow@example.com",
    });
    if (!user) {
      user = await User.create({
        username: "test_observer",
        email: "test_observation_flow@example.com",
        password: "test123",
      });
      log("Created test user", user._id);
    }

    // 2) Create a simple plant template with 3 stages (schema requires 3-6 stages)
    const template = await PlantTemplate.create({
      template_name: `test_template_obs_${Date.now()}`,
      plant_group: "other",
      stages: [
        {
          stage_number: 1,
          name: "Stage 1",
          day_start: 1,
          day_end: 2,
          autogenerated_tasks: [
            { task_name: "water", frequency: "daily" },
            { task_name: "fertilize", frequency: "once" },
          ],
          observation_required: [{ key: "has_sprout", label: "Đã nảy mầm?" }],
        },
        {
          stage_number: 2,
          name: "Stage 2",
          day_start: 3,
          day_end: 5,
          autogenerated_tasks: [
            {
              task_name: "water",
              frequency: "daily",
              description: "Tưới nước",
            },
            {
              task_name: "inspect_leaves",
              frequency: "once",
              description: "Kiểm tra lá",
            },
            {
              task_name: "fertilize",
              frequency: "every_3_days",
              description: "Bón phân",
            },
          ],
        },
        {
          stage_number: 3,
          name: "Stage 3",
          day_start: 6,
          day_end: 10,
          autogenerated_tasks: [],
        },
      ],
      created_by: user._id,
      status: "active",
    });

    log("Created template", template._id);

    // 3) Create a notebook planted_date = 2025-11-24 (VN local date)
    const planted = parseVietnamDate("2025-11-24");
    let nb = await Notebook.create({
      user_id: user._id,
      notebook_name: "Test observation blocking",
      plant_type: "test",
      plant_group: "other",
      planted_date: planted,
      template_id: template._id,
      stages_tracking: template.stages.map((s, i) => ({
        stage_number: s.stage_number,
        stage_name: s.name,
        started_at: i === 0 ? planted : null,
        is_current: i === 0,
      })),
    });

    log("Created notebook", nb._id, "planted_date", planted.toISOString());

    // 4) Generate checklist for day 1 (2025-11-24)
    await generateDailyChecklist(nb._id);
    nb = await Notebook.findById(nb._id);
    log(
      "After day1 generate, daily_checklist:",
      nb.daily_checklist.map((t) => ({ name: t.task_name, status: t.status }))
    );

    // 5) Simulate next day: call generateDailyChecklist again (this should mark day1 pending tasks as overdue and create new day's checklist)
    // To simulate moving to next VN day, we set last_checklist_generated to yesterday (day 24)
    nb.last_checklist_generated = toVietnamMidnight(planted); // simulate it was generated on 24
    await nb.save();

    // Now call generateDailyChecklist - it will consider lastGenerated < today and mark overdue
    await generateDailyChecklist(nb._id);
    nb = await Notebook.findById(nb._id);
    log(
      "After day2 generate, overdue_tasks:",
      nb.stages_tracking[0].overdue_tasks || []
    );
    log(
      "Daily checklist for day2:",
      nb.daily_checklist.map((t) => ({ name: t.task_name, status: t.status }))
    );

    // 6) Attempt to update observation on day2 -> should fail because overdue + today's tasks not completed
    try {
      await updateStageObservation(nb._id, "has_sprout", true);
      log(
        "ERROR: observation update unexpectedly succeeded when tasks incomplete"
      );
    } catch (e) {
      log(
        "Expected failure updating observation (tasks incomplete):",
        e.message
      );
    }

    // 7) Complete overdue tasks and today's tasks
    // Mark overdue entries in stage tracking as completed
    const st = nb.stages_tracking[0];
    if (st.overdue_tasks && st.overdue_tasks.length > 0) {
      st.overdue_tasks.forEach((t) => {
        t.status = "completed";
        t.overdue_at = t.overdue_at || new Date();
      });
    }
    // Mark today's checklist items as completed
    nb.daily_checklist.forEach((t) => {
      t.is_completed = true;
      t.status = "completed";
      t.completed_at = new Date();
    });
    // Also mirror completions into completed_tasks
    st.completed_tasks = st.completed_tasks || [];
    nb.daily_checklist.forEach((t) =>
      st.completed_tasks.push({
        task_name: t.task_name,
        completed_at: t.completed_at,
      })
    );

    await nb.save();
    log("Completed overdue + today's tasks and saved notebook");

    // 8) Now attempt to update observation again -> should succeed
    try {
      const updated = await updateStageObservation(nb._id, "has_sprout", true);
      log("Observation update result:", updated._id ? "ok" : updated);
    } catch (e) {
      log(
        "ERROR: observation update failed after completing tasks:",
        e.message
      );
    }

    // 9) Check pending_transition flag set
    nb = await Notebook.findById(nb._id);
    log(
      "Stage tracking after observation:",
      nb.stages_tracking[0].pending_transition,
      nb.stages_tracking[0].transition_date
    );

    // 10) Simulate next day by calling generateDailyChecklist again (it should perform auto-transition)
    // Set last_checklist_generated to yesterday to force generation
    nb.last_checklist_generated = toVietnamMidnight(
      new Date(nb.last_checklist_generated || new Date())
    );
    await nb.save();

    await generateDailyChecklist(nb._id);
    nb = await Notebook.findById(nb._id);
    log("After next day generate, current_stage:", nb.current_stage);

    // 11) Simulate the day AFTER pending_transition: set transition_date to yesterday
    // so generateDailyChecklist will detect it's time to auto-transition.
    const yesterday = new Date(getVietnamToday());
    yesterday.setDate(yesterday.getDate() - 1);

    const currentTracking = nb.stages_tracking.find(
      (s) => s.stage_number === nb.current_stage
    );
    if (currentTracking) {
      currentTracking.transition_date = toVietnamMidnight(yesterday);
      await nb.save();
      log(
        "Forced transition_date to yesterday to simulate next day transition:",
        currentTracking.transition_date.toISOString()
      );
    }

    // Call generateDailyChecklist again to trigger auto-transition to next stage
    await generateDailyChecklist(nb._id);
    nb = await Notebook.findById(nb._id).populate("template_id");
    log("After simulated next-day generate, current_stage:", nb.current_stage);

    // Check that new stage tasks are generated and that new stage completion is 0%
    const newStageChecklist = nb.daily_checklist || [];
    const newStageTracking = nb.stages_tracking.find(
      (s) => s.stage_number === nb.current_stage
    );
    const newStageCompletion = await nb.getCurrentStageCompletion();
    log(
      "New stage checklist items:",
      newStageChecklist.map((t) => ({ name: t.task_name, status: t.status }))
    );
    log(
      "New stage daily_logs length:",
      newStageTracking && newStageTracking.daily_logs
        ? newStageTracking.daily_logs.length
        : 0
    );
    log("New stage completion % (expected 0):", newStageCompletion);

    console.log("TEST FLOW COMPLETE");

    // Cleanup: optional - do not delete created records automatically
    // NOTE: do not disconnect here because we may run additional scenarios afterwards
    // await mongoose.disconnect();
    // log("Disconnected");
  } catch (err) {
    console.error("Test error", err);
    process.exitCode = 1;
  }
}

// Run main then run safe-delay scenario to validate safe_delay_days behavior
main().then(async () => {
  // small wrapper for safe-delay scenario
  try {
    console.log("\n--- Running safeDelayScenario (safe_delay_days = 1) ---");

    const user = await User.findOne({
      email: "test_observation_flow@example.com",
    });
    if (!user) throw new Error("Test user not found");

    const tpl = await PlantTemplate.create({
      template_name: `test_template_safe_delay_${Date.now()}`,
      plant_group: "other",
      rules: { safe_delay_days: 1, auto_skip: true },
      stages: [
        {
          stage_number: 1,
          name: "S1",
          day_start: 1,
          day_end: 2,
          autogenerated_tasks: [{ task_name: "water", frequency: "daily" }],
          observation_required: [{ key: "obs_ready", label: "Ready?" }],
        },
        {
          stage_number: 2,
          name: "S2",
          day_start: 3,
          day_end: 5,
          autogenerated_tasks: [],
        },
        {
          stage_number: 3,
          name: "S3",
          day_start: 6,
          day_end: 10,
          autogenerated_tasks: [],
        },
      ],
      created_by: user._id,
      status: "active",
    });

    console.log("Created safe-delay template", tpl._id.toString());

    const planted = parseVietnamDate("2025-11-24");
    let nb2 = await Notebook.create({
      user_id: user._id,
      notebook_name: "Test safe delay",
      plant_type: "test",
      plant_group: "other",
      planted_date: planted,
      template_id: tpl._id,
      stages_tracking: tpl.stages.map((s, i) => ({
        stage_number: s.stage_number,
        stage_name: s.name,
        started_at: i === 0 ? planted : null,
        is_current: i === 0,
      })),
    });

    console.log(
      "Created safe-delay notebook",
      nb2._id.toString(),
      "planted",
      planted.toISOString()
    );

    // Day 25: observations available but not checked
    await generateDailyChecklist(nb2._id);
    nb2 = await Notebook.findById(nb2._id).populate("template_id");
    console.log(
      "Day25 checklist:",
      nb2.daily_checklist.map((t) => t.task_name)
    );

    // Simulate Day26: shift planted_date back 1 day so missedDays = 1
    nb2.planted_date = new Date(planted);
    nb2.planted_date.setDate(nb2.planted_date.getDate() - 1);
    await nb2.save();

    await checkNotebookStageStatus(nb2);
    nb2 = await Notebook.findById(nb2._id).populate("template_id");
    const st = nb2.stages_tracking.find(
      (s) => s.stage_number === nb2.current_stage
    );
    console.log(
      "After Day26 check: status:",
      st.status,
      "missed_days:",
      st.missed_days
    );

    // Simulate Day27: shift planted_date back another day so missedDays = 2 (> safe_delay_days)
    nb2.planted_date.setDate(nb2.planted_date.getDate() - 1);
    await nb2.save();

    await checkNotebookStageStatus(nb2);
    nb2 = await Notebook.findById(nb2._id).populate("template_id");
    const s1 = nb2.stages_tracking.find((s) => s.stage_number === 1);
    console.log(
      "After Day27 check: stage1 status:",
      s1.status,
      "current_stage:",
      nb2.current_stage
    );

    console.log("--- safeDelayScenario complete ---");
  } catch (e) {
    console.error("safeDelayScenario error", e);
  } finally {
    // ensure mongoose disconnect at the end of entire run
    try {
      await mongoose.disconnect();
      console.log("Disconnected (final)");
    } catch (e) {}
  }
});
