import Notebook from "../models/Notebook.js";
import mongoose from "mongoose";
import Guide from "../models/Guide.js";
import PlantTemplate from "../models/PlantTemplate.js";
import { ok, created, noContent } from "../utils/ApiResponse.js";
import { asyncHandler } from "../utils/asyncHandler.js";
import { AppError } from "../utils/AppError.js";
import {
  sendStageWarningNotification,
  sendStageSkippedNotification,
  sendStageOverdueNotification,
} from "./notificationController.js";
import { sendDailyReminderNotification } from "./notificationController.js";
import {
  getDaysDifferenceVN,
  toVietnamMidnight,
  getVietnamToday,
  formatVietnamDate,
  parseVietnamDate,
} from "../utils/timezone.js";

// ==========================================
// HELPER FUNCTIONS (from services)
// ==========================================

/**
 * T√≠nh s·ªë ng√†y t·ª´ startDate ƒë·∫øn endDate (theo gi·ªù Vi·ªát Nam UTC+7)
 * S·ª≠ d·ª•ng helper t·ª´ timezone.js
 */
const getDaysDifference = getDaysDifferenceVN;

/**
 * T√≠nh stage end date d·ª±a tr√™n planted_date v√† stage.day_end (theo gi·ªù Vi·ªát Nam UTC+7)
 */
const getStageEndDate = (plantedDate, stageEndDay) => {
  const endDate = new Date(plantedDate);
  endDate.setDate(endDate.getDate() + stageEndDay - 1);
  return toVietnamMidnight(endDate);
};

/**
 * T√≠nh ng√†y b·∫Øt ƒë·∫ßu c·ªßa stage d·ª±a tr√™n planted_date v√† stage.day_start
 */
const getStageStartDate = (plantedDate, stageStartDay) => {
  const startDate = new Date(plantedDate);
  startDate.setDate(startDate.getDate() + stageStartDay - 1);
  return toVietnamMidnight(startDate);
};

/**
 * Ki·ªÉm tra xem notification ƒë√£ ƒë∆∞·ª£c g·ª≠i ch∆∞a
 */
const hasNotificationBeenSent = (notificationsSent, type, missedDay) => {
  return notificationsSent?.some((n) => n.type === type && n.day === missedDay);
};

/**
 * L·∫•y template ph√π h·ª£p v·ªõi notebook (d·ª±a tr√™n guide's plant_group)
 */
const getTemplateForNotebook = async (notebookId) => {
  const notebook = await Notebook.findById(notebookId).populate("guide_id");

  if (!notebook) {
    throw new AppError("Kh√¥ng t√¨m th·∫•y nh·∫≠t k√Ω", 404);
  }

  if (notebook.template_id) {
    const template = await PlantTemplate.findById(notebook.template_id);
    return template;
  }

  if (notebook.guide_id && notebook.guide_id.plant_group) {
    const template = await PlantTemplate.findOne({
      plant_group: notebook.guide_id.plant_group,
      status: "active",
    }).sort({ usage_count: -1 });

    return template;
  }

  return null;
};

/**
 * G√°n template cho notebook
 */
const assignTemplateToNotebook = async (notebookId, templateId) => {
  const notebook = await Notebook.findById(notebookId);
  const template = await PlantTemplate.findById(templateId);

  if (!notebook) {
    throw new AppError("Kh√¥ng t√¨m th·∫•y nh·∫≠t k√Ω", 404);
  }

  if (!template) {
    throw new AppError("Kh√¥ng t√¨m th·∫•y template", 404);
  }

  notebook.template_id = templateId;

  notebook.stages_tracking = template.stages.map((stage, index) => ({
    stage_number: stage.stage_number,
    stage_name: stage.name,
    started_at:
      index === 0
        ? getStageStartDate(notebook.planted_date, stage.day_start)
        : null,
    is_current: index === 0,
  }));

  notebook.current_stage = 1;

  // ‚úÖ Kh·ªüi t·∫°o progress = 0 khi g√°n template l·∫ßn ƒë·∫ßu
  // Progress s·∫Ω ch·ªâ tƒÉng l√™n khi ho√†n th√†nh observations ·ªü cu·ªëi m·ªói stage
  notebook.progress = 0;

  await notebook.save();

  template.usage_count += 1;
  await template.save();

  await generateDailyChecklist(notebookId);

  return notebook;
};

/**
 * T·∫°o daily checklist t·ª´ template's autogenerated_tasks
 */
export const generateDailyChecklist = async (notebookId) => {
  const notebook = await Notebook.findById(notebookId).populate("template_id");

  if (!notebook || !notebook.template_id) {
    return null;
  }

  const template = notebook.template_id;
  const today = getVietnamToday();

  // üîÑ KI·ªÇM TRA V√Ä T·ª∞ ƒê·ªòNG CHUY·ªÇN STAGE N·∫æU C√ì PENDING TRANSITION
  const currentStageTracking = notebook.stages_tracking?.find(
    (s) => s.stage_number === notebook.current_stage
  );

  if (currentStageTracking?.pending_transition) {
    const transitionDate = currentStageTracking.transition_date
      ? toVietnamMidnight(new Date(currentStageTracking.transition_date))
      : null;

    // N·∫øu ƒë√£ qua ng√†y ho√†n th√†nh observations ‚Üí chuy·ªÉn stage
    if (transitionDate && today.getTime() > transitionDate.getTime()) {
      console.log(
        `üîÑ Auto-transitioning from stage ${notebook.current_stage} (observations completed yesterday)`
      );

      const nextStageNumber = notebook.current_stage + 1;
      if (nextStageNumber <= template.stages.length) {
        // T·∫Øt current flag c·ªßa stage hi·ªán t·∫°i
        currentStageTracking.is_current = false;
        currentStageTracking.pending_transition = false;

        // B·∫≠t current flag cho stage ti·∫øp theo
        const nextStageTracking = notebook.stages_tracking.find(
          (s) => s.stage_number === nextStageNumber
        );

        if (nextStageTracking) {
          nextStageTracking.is_current = true;
          const nextTemplateStage = template.stages.find(
            (s) => s.stage_number === nextStageNumber
          );
          if (nextTemplateStage) {
            nextStageTracking.started_at = getStageStartDate(
              notebook.planted_date,
              nextTemplateStage.day_start
            );
          } else {
            nextStageTracking.started_at = today;
          }
          nextStageTracking.status = "active";
        }

        // C·∫≠p nh·∫≠t current_stage
        notebook.current_stage = nextStageNumber;
        await notebook.save();

        console.log(`‚úÖ Stage switched to ${nextStageNumber}`);
      }
    }
  }

  // Reload l·∫°i sau khi c√≥ th·ªÉ ƒë√£ chuy·ªÉn stage
  const updatedStageTracking = notebook.stages_tracking?.find(
    (s) => s.stage_number === notebook.current_stage
  );

  const currentStage = template.stages.find(
    (s) => s.stage_number === notebook.current_stage
  );

  if (!currentStage) {
    console.log(
      `‚ö†Ô∏è generateDailyChecklist: template stage not found for notebook ${notebookId} stage ${notebook.current_stage}`
    );
    return null;
  }

  // daysInStage: if tracking started_at exists use it, otherwise fallback to template-based calculation
  let daysInStage;
  if (updatedStageTracking && updatedStageTracking.started_at) {
    daysInStage = getDaysDifference(updatedStageTracking.started_at, today) + 1;
  } else {
    daysInStage = Math.floor(notebook.current_day) - currentStage.day_start + 1;
  }

  // N·∫øu ƒë√£ c√≥ checklist ƒë∆∞·ª£c sinh v√†o ng√†y tr∆∞·ªõc ƒë√≥ -> sang ng√†y m·ªõi, x·ª≠ l√Ω
  // c√°c task ch∆∞a ho√†n th√†nh c·ªßa ng√†y tr∆∞·ªõc th√†nh overdue, ghi v√†o stages_tracking
  const lastGenerated = notebook.last_checklist_generated
    ? toVietnamMidnight(new Date(notebook.last_checklist_generated))
    : null;

  if (lastGenerated && lastGenerated.getTime() < today.getTime()) {
    if (updatedStageTracking) {
      const incompleteTasks = (notebook.daily_checklist || []).filter(
        (t) => !t.is_completed && t.status === "pending"
      );

      if (incompleteTasks.length > 0) {
        // Ensure overdue_tasks array exists
        if (!updatedStageTracking.overdue_tasks)
          updatedStageTracking.overdue_tasks = [];

        incompleteTasks.forEach((task) => {
          // mark the checklist item as overdue
          task.status = "overdue";
          task.overdue_at = today;

          // persist an overdue task entry for history and UI
          updatedStageTracking.overdue_tasks.push({
            task_name: task.task_name,
            description: task.description || "",
            original_date: lastGenerated,
            status: "overdue",
            overdue_at: today,
          });
        });

        updatedStageTracking.overdue_summary = {
          date: lastGenerated,
          overdue_count: incompleteTasks.length,
          ready_to_notify: true,
        };

        // Try to send immediate daily reminder notification
        try {
          await sendDailyReminderNotification({
            userId: notebook.user_id,
            notebookId: notebook._id,
            notebookName: notebook.notebook_name,
            incompleteTasks: incompleteTasks.length,
          });
        } catch (e) {
          console.warn("Failed to send daily reminder notification:", e);
        }
      }
    }
  }

  let newChecklist = [];
  const allTasks =
    currentStage.autogenerated_tasks || currentStage.daily_tasks || [];
  if (daysInStage === 1) {
    // Ng√†y ƒë·∫ßu stage: hi·ªÉn th·ªã to√†n b·ªô task
    newChecklist = allTasks.map((task) => {
      let completedEntry = null;
      if (updatedStageTracking?.completed_tasks) {
        completedEntry = updatedStageTracking.completed_tasks.find((t) => {
          if (t.task_name !== task.task_name) return false;
          if (!t.completed_at) return false;
          try {
            const completedAt = toVietnamMidnight(new Date(t.completed_at));
            return completedAt.getTime() === today.getTime();
          } catch (e) {
            return false;
          }
        });
      }
      const isCompleted = !!completedEntry;
      return {
        task_name: task.task_name,
        description: task.description,
        priority: task.priority,
        frequency: task.frequency,
        is_completed: isCompleted,
        status: isCompleted ? "completed" : "pending",
        completed_at: isCompleted ? completedEntry.completed_at : null,
        created_at: today,
      };
    });
  } else {
    // Nh·ªØng ng√†y ti·∫øp theo: ch·ªâ hi·ªÉn th·ªã task theo t·∫ßn su·∫•t
    newChecklist = allTasks
      .filter((task) => {
        // Always show daily tasks
        if (task.frequency === "daily") return true;

        // Interval-based tasks: prefer last completion date if available
        const intervalMap = {
          every_2_days: 2,
          every_3_days: 3,
          weekly: 7,
        };

        const interval = intervalMap[task.frequency];
        if (!interval) return false;

        // Find last completed entry for this task in current stage
        const lastCompleted = updatedStageTracking?.completed_tasks
          ? updatedStageTracking.completed_tasks
              .filter((t) => t.task_name === task.task_name)
              .reduce((latest, t) => {
                if (!latest) return t;
                return new Date(t.completed_at) > new Date(latest.completed_at)
                  ? t
                  : latest;
              }, null)
          : null;

        if (lastCompleted && lastCompleted.completed_at) {
          const daysSinceLast = getDaysDifference(
            lastCompleted.completed_at,
            today
          );
          // Show when days since last completion is >= interval and matches the interval cadence
          return daysSinceLast >= interval && daysSinceLast % interval === 0;
        }

        // Fallback to original stage-based cadence if never completed in this stage
        // We treat the first day of the stage as day 1 (anchor). For an
        // "every_N_days" cadence we want to show on day 1, then day 1+N,
        // 1+2N, ... so use (daysInStage - 1) % interval === 0.
        return (daysInStage - 1) % interval === 0;
      })
      .map((task) => {
        let completedEntry = null;
        if (updatedStageTracking?.completed_tasks) {
          completedEntry = updatedStageTracking.completed_tasks.find((t) => {
            if (t.task_name !== task.task_name) return false;
            if (!t.completed_at) return false;
            try {
              const completedAt = toVietnamMidnight(new Date(t.completed_at));
              return completedAt.getTime() === today.getTime();
            } catch (e) {
              return false;
            }
          });
        }
        const isCompleted = !!completedEntry;
        return {
          task_name: task.task_name,
          description: task.description,
          priority: task.priority,
          frequency: task.frequency,
          is_completed: isCompleted,
          status: isCompleted ? "completed" : "pending",
          completed_at: isCompleted ? completedEntry.completed_at : null,
          created_at: today,
        };
      });
  }
  newChecklist = (
    currentStage.autogenerated_tasks ||
    currentStage.daily_tasks ||
    []
  )
    .filter((task) => {
      // If this is the first day in the stage, include every task (we'll mark
      // completed ones as completed). For subsequent days, apply the
      // frequency-based filters below.
      if (daysInStage === 1) return true;

      // Always show daily tasks
      if (task.frequency === "daily") return true;

      // One-time tasks: show only on first day of stage if not already completed
      if (task.frequency === "once") {
        const alreadyCompleted = updatedStageTracking?.completed_tasks?.some(
          (t) => t.task_name === task.task_name
        );
        return !alreadyCompleted && daysInStage === 1;
      }

      // Interval-based tasks: prefer last completion date if available
      const intervalMap = {
        every_2_days: 2,
        every_3_days: 3,
        weekly: 7,
      };

      const interval = intervalMap[task.frequency];
      if (!interval) return false;

      // Find last completed entry for this task in current stage
      const lastCompleted = updatedStageTracking?.completed_tasks
        ? updatedStageTracking.completed_tasks
            .filter((t) => t.task_name === task.task_name)
            .reduce((latest, t) => {
              if (!latest) return t;
              return new Date(t.completed_at) > new Date(latest.completed_at)
                ? t
                : latest;
            }, null)
        : null;

      if (lastCompleted && lastCompleted.completed_at) {
        const daysSinceLast = getDaysDifference(
          lastCompleted.completed_at,
          today
        );
        // Show when days since last completion is >= interval and matches the interval cadence
        return daysSinceLast >= interval && daysSinceLast % interval === 0;
      }

      // Fallback to original stage-based cadence if never completed in this stage
      // Anchor at stage day 1, so only show when (daysInStage - 1) is a multiple
      // of the interval (day 1, 1+interval, ...).
      return (daysInStage - 1) % interval === 0;
    })
    .map((task) => {
      // Consider a task completed ONLY if there is a completed_tasks entry
      // whose completed_at is TODAY (not just any day in the stage)
      let completedEntry = null;
      if (updatedStageTracking?.completed_tasks) {
        completedEntry = updatedStageTracking.completed_tasks.find((t) => {
          if (t.task_name !== task.task_name) return false;
          if (!t.completed_at) return false;
          try {
            const completedAt = toVietnamMidnight(new Date(t.completed_at));
            // ‚úÖ CH·ªà mark completed n·∫øu completed_at l√† H√îM NAY
            return completedAt.getTime() === today.getTime();
          } catch (e) {
            return false;
          }
        });
      }
      const isCompleted = !!completedEntry;
      return {
        task_name: task.task_name,
        description: task.description,
        priority: task.priority,
        frequency: task.frequency,
        is_completed: isCompleted,
        status: isCompleted ? "completed" : "pending",
        completed_at: isCompleted ? completedEntry.completed_at : null,
        created_at: today,
      };
    });

  notebook.daily_checklist = newChecklist;
  notebook.last_checklist_generated = today;
  await notebook.save();

  return newChecklist;
};

/**
 * C·∫≠p nh·∫≠t stage hi·ªán t·∫°i
 */
const updateCurrentStage = async (notebookId, newStageNumber) => {
  const notebook = await Notebook.findById(notebookId).populate("template_id");

  if (!notebook || !notebook.template_id) {
    throw new AppError("Kh√¥ng t√¨m th·∫•y nh·∫≠t k√Ω ho·∫∑c template", 404);
  }

  const template = notebook.template_id;

  if (newStageNumber > template.stages.length) {
    throw new AppError("S·ªë stage kh√¥ng h·ª£p l·ªá", 400);
  }

  const oldStageIndex = notebook.stages_tracking.findIndex(
    (s) => s.stage_number === notebook.current_stage
  );
  if (oldStageIndex !== -1) {
    notebook.stages_tracking[oldStageIndex].is_current = false;
    // Set completed_at to the template-based stage end date (normalized to VN day-start)
    const oldStageNumber = notebook.current_stage;
    const oldTemplateStage = template.stages.find(
      (s) => s.stage_number === oldStageNumber
    );
    if (oldTemplateStage) {
      notebook.stages_tracking[oldStageIndex].completed_at = getStageEndDate(
        notebook.planted_date,
        oldTemplateStage.day_end
      );
    } else {
      notebook.stages_tracking[oldStageIndex].completed_at = new Date();
    }
  }

  const newStageIndex = notebook.stages_tracking.findIndex(
    (s) => s.stage_number === newStageNumber
  );
  if (newStageIndex !== -1) {
    notebook.stages_tracking[newStageIndex].is_current = true;
    // When activating a new stage, set its started_at to the template-planned start date
    // (planted_date + stage.day_start - 1) normalized to VN day-start. This keeps
    // persisted started_at consistent with the template schedule for future notebooks.
    const newTemplateStage = template.stages.find(
      (s) => s.stage_number === newStageNumber
    );
    if (newTemplateStage) {
      notebook.stages_tracking[newStageIndex].started_at = getStageStartDate(
        notebook.planted_date,
        newTemplateStage.day_start
      );
    } else {
      notebook.stages_tracking[newStageIndex].started_at = getVietnamToday();
    }
  }

  notebook.current_stage = newStageNumber;

  // ‚ö†Ô∏è KHÔøΩÔøΩNG c·∫≠p nh·∫≠t progress ·ªü ƒë√¢y - ch·ªâ c·∫≠p nh·∫≠t khi ho√†n th√†nh observations
  // N·∫øu admin/user chuy·ªÉn stage th·ªß c√¥ng, progress s·∫Ω ƒë∆∞·ª£c c·∫≠p nh·∫≠t khi h·ªç ho√†n th√†nh observations
  // await notebook.updateProgress(template.stages);

  await notebook.save();

  // Generate today's checklist immediately for the newly-activated stage
  await generateDailyChecklist(notebookId);

  return notebook;
};

/**
 * Ki·ªÉm tra v√† x·ª≠ l√Ω tr·∫°ng th√°i stage c·ªßa notebook (stage monitoring)
 */
export const checkNotebookStageStatus = async (notebook) => {
  try {
    if (!notebook.populated("template_id")) {
      await notebook.populate("template_id");
    }

    if (!notebook.template_id || !notebook.template_id.stages) {
      console.log(`‚ö†Ô∏è Notebook ${notebook._id} kh√¥ng c√≥ template`);
      return;
    }

    const template = notebook.template_id;
    const today = getVietnamToday();

    const currentStageTracking = notebook.stages_tracking.find(
      (s) => s.stage_number === notebook.current_stage
    );

    if (!currentStageTracking) {
      console.log(
        `‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y stage_tracking cho stage ${notebook.current_stage}`
      );
      return;
    }

    if (
      currentStageTracking.status === "completed" ||
      currentStageTracking.status === "skipped"
    ) {
      console.log(
        `‚úÖ Stage ${notebook.current_stage} ƒë√£ ${currentStageTracking.status}, b·ªè qua`
      );
      return;
    }

    const templateStage = template.stages.find(
      (s) => s.stage_number === notebook.current_stage
    );

    if (!templateStage) {
      console.log(
        `‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y template stage cho stage ${notebook.current_stage}`
      );
      return;
    }

    const stageEndDate = getStageEndDate(
      notebook.planted_date,
      templateStage.day_end
    );
    const daysAfterEnd = getDaysDifference(stageEndDate, today);

    console.log(
      `üìÖ Notebook: ${notebook.notebook_name} | Stage: ${
        templateStage.name
      } | End Date: ${
        stageEndDate.toISOString().split("T")[0]
      } | Days After End: ${daysAfterEnd}`
    );

    // üîç KI·ªÇM TRA OBSERVATIONS QU√Å H·∫†N
    // N·∫øu ƒëang ·ªü cu·ªëi giai ƒëo·∫°n v√† ch∆∞a ho√†n th√†nh observations
    const currentDay = notebook.current_day || 1;
    const isLastDayOfStage = currentDay === templateStage.day_end;

    if (
      isLastDayOfStage &&
      templateStage.observation_required &&
      templateStage.observation_required.length > 0
    ) {
      const completedObservations =
        currentStageTracking.observations?.filter(
          (obs) => obs.value === true
        ) || [];

      const allObservationsCompleted =
        completedObservations.length >=
        templateStage.observation_required.length;

      if (!allObservationsCompleted) {
        console.log(
          `‚ö†Ô∏è Observations ch∆∞a ho√†n th√†nh (${completedObservations.length}/${templateStage.observation_required.length})`
        );
      }
    }

    if (daysAfterEnd <= 0) {
      console.log(`‚úÖ Stage ${notebook.current_stage} c√≤n trong th·ªùi h·∫°n`);
      return;
    }

    const missedDays = daysAfterEnd;
    const safeDelayDays = template.rules?.safe_delay_days || 2;
    const autoSkip = template.rules?.auto_skip ?? true;

    console.log(
      `‚ö†Ô∏è Stage ${notebook.current_stage} ƒë√£ tr·ªÖ ${missedDays} ng√†y (safe_delay: ${safeDelayDays})`
    );

    currentStageTracking.missed_days = missedDays;

    if (missedDays <= safeDelayDays) {
      if (
        !hasNotificationBeenSent(
          currentStageTracking.notifications_sent,
          "warning",
          missedDays
        )
      ) {
        await sendStageWarningNotification({
          userId: notebook.user_id,
          notebookId: notebook._id,
          notebookName: notebook.notebook_name,
          stageNumber: notebook.current_stage,
          stageName: templateStage.name,
          missedDays,
          safeDelayDays,
        });

        if (!currentStageTracking.notifications_sent) {
          currentStageTracking.notifications_sent = [];
        }
        currentStageTracking.notifications_sent.push({
          type: "warning",
          day: missedDays,
          sent_at: new Date(),
        });

        if (currentStageTracking.status !== "overdue") {
          currentStageTracking.status = "overdue";
        }

        await notebook.save();
        console.log(
          `üìß ƒê√£ g·ª≠i c·∫£nh b√°o l·∫ßn ${missedDays} cho stage ${notebook.current_stage}`
        );
      } else {
        console.log(`‚è≠Ô∏è ƒê√£ g·ª≠i c·∫£nh b√°o cho missedDay ${missedDays}, b·ªè qua`);
      }
    } else {
      if (
        !hasNotificationBeenSent(
          currentStageTracking.notifications_sent,
          "exceeded",
          missedDays
        )
      ) {
        if (autoSkip) {
          currentStageTracking.status = "completed"; // ‚úÖ ƒê√°nh d·∫•u completed thay v√¨ skipped
          // Mark completed_at using template-based stage end date
          currentStageTracking.completed_at = getStageEndDate(
            notebook.planted_date,
            templateStage.day_end
          );
          currentStageTracking.is_current = false;

          // ‚úÖ T·ª∞ ƒê·ªòNG HO√ÄN TH√ÄNH OBSERVATIONS N·∫æU C√ì
          if (
            templateStage.observation_required &&
            templateStage.observation_required.length > 0
          ) {
            console.log(
              `ü§ñ Auto-completing observations due to exceeded delay`
            );

            // ƒê√°nh d·∫•u t·∫•t c·∫£ observations = true
            templateStage.observation_required.forEach((obsReq) => {
              const existing = currentStageTracking.observations?.find(
                (o) => o.key === obsReq.key
              );
              if (existing) {
                existing.value = true;
                existing.observed_at = new Date();
              } else {
                if (!currentStageTracking.observations) {
                  currentStageTracking.observations = [];
                }
                currentStageTracking.observations.push({
                  key: obsReq.key,
                  value: true,
                  observed_at: new Date(),
                });
              }
            });

            // ‚úÖ C·∫¨P NH·∫¨T PROGRESS v√¨ ƒë√£ ho√†n th√†nh stage
            await notebook.updateProgress(template.stages);
            console.log(`üå± Plant progress updated: ${notebook.progress}%`);
          }

          await sendStageSkippedNotification({
            userId: notebook.user_id,
            notebookId: notebook._id,
            notebookName: notebook.notebook_name,
            stageNumber: notebook.current_stage,
            stageName: templateStage.name,
            missedDays,
            safeDelayDays,
          });

          const nextStageNumber = notebook.current_stage + 1;
          if (nextStageNumber <= template.stages.length) {
            const nextStageTracking = notebook.stages_tracking.find(
              (s) => s.stage_number === nextStageNumber
            );
            if (nextStageTracking) {
              nextStageTracking.is_current = true;
              // Activate stage using template-planned start date to keep persisted
              // timeline consistent with template schedule for future notebooks.
              const nextTemplateStage = template.stages.find(
                (s) => s.stage_number === nextStageNumber
              );
              if (nextTemplateStage) {
                nextStageTracking.started_at = getStageStartDate(
                  notebook.planted_date,
                  nextTemplateStage.day_start
                );
              } else {
                nextStageTracking.started_at = getVietnamToday();
              }
              nextStageTracking.status = "active";
            }
            notebook.current_stage = nextStageNumber;

            console.log(
              `‚è≠Ô∏è T·ª± ƒë·ªông ho√†n th√†nh observations v√† chuy·ªÉn sang stage ${nextStageNumber}`
            );
          } else {
            console.log(`üèÅ ƒê√£ h·∫øt stage, kh√¥ng th·ªÉ chuy·ªÉn stage ti·∫øp theo`);
          }

          if (!currentStageTracking.notifications_sent) {
            currentStageTracking.notifications_sent = [];
          }
          currentStageTracking.notifications_sent.push({
            type: "exceeded",
            day: missedDays,
            sent_at: new Date(),
          });

          await notebook.save();
          // Generate checklist for the new stage immediately
          await generateDailyChecklist(notebook._id);
        } else {
          currentStageTracking.status = "overdue";

          await sendStageOverdueNotification({
            userId: notebook.user_id,
            notebookId: notebook._id,
            notebookName: notebook.notebook_name,
            stageNumber: notebook.current_stage,
            stageName: templateStage.name,
            missedDays,
            safeDelayDays,
          });

          if (!currentStageTracking.notifications_sent) {
            currentStageTracking.notifications_sent = [];
          }
          currentStageTracking.notifications_sent.push({
            type: "exceeded",
            day: missedDays,
            sent_at: new Date(),
          });

          await notebook.save();
          console.log(
            `üö® Stage ${notebook.current_stage} ƒë√£ qu√° h·∫°n, y√™u c·∫ßu can thi·ªáp th·ªß c√¥ng`
          );
        }
      } else {
        console.log(`‚è≠Ô∏è ƒê√£ x·ª≠ l√Ω exceeded cho missedDay ${missedDays}, b·ªè qua`);
      }
    }
  } catch (error) {
    console.error(`‚ùå L·ªói khi check notebook ${notebook._id}:`, error);
  }
};

/**
 * ƒê√°nh d·∫•u ho√†n th√†nh task trong checklist
 */
const completeChecklistTask = async (notebookId, taskName) => {
  // Ensure today's checklist exists (generate if needed) so progress calculation is accurate
  await generateDailyChecklist(notebookId);
  const notebook = await Notebook.findById(notebookId).populate("template_id");

  if (!notebook) {
    throw new AppError("Kh√¥ng t√¨m th·∫•y nh·∫≠t k√Ω", 404);
  }

  const task = notebook.daily_checklist.find((t) => t.task_name === taskName);

  if (!task) {
    throw new AppError("Kh√¥ng t√¨m th·∫•y c√¥ng vi·ªác", 404);
  }

  task.is_completed = !task.is_completed;
  task.completed_at = task.is_completed ? new Date() : null;
  task.status = task.is_completed ? "completed" : "pending"; // ‚úÖ Update status

  const currentStageTracking = notebook.stages_tracking.find(
    (s) => s.stage_number === notebook.current_stage
  );

  if (currentStageTracking) {
    if (task.is_completed) {
      const alreadyCompleted = currentStageTracking.completed_tasks?.some(
        (t) => t.task_name === taskName
      );

      if (!alreadyCompleted) {
        if (!currentStageTracking.completed_tasks) {
          currentStageTracking.completed_tasks = [];
        }
        currentStageTracking.completed_tasks.push({
          task_name: taskName,
          completed_at: new Date(),
        });
      }
    } else {
      if (currentStageTracking.completed_tasks) {
        currentStageTracking.completed_tasks =
          currentStageTracking.completed_tasks.filter(
            (t) => t.task_name !== taskName
          );
      }
    }
  }

  // ‚ö†Ô∏è KH√îNG c·∫≠p nh·∫≠t progress ·ªü ƒë√¢y - ch·ªâ c·∫≠p nh·∫≠t khi ho√†n th√†nh observations
  // Progress ch·ªâ ƒë∆∞·ª£c c·∫≠p nh·∫≠t khi ho√†n th√†nh t·∫•t c·∫£ observations ·ªü cu·ªëi giai ƒëo·∫°n
  if (notebook.template_id && notebook.template_id.stages) {
    console.log(
      `üìã Completed tasks in current stage: ${
        currentStageTracking?.completed_tasks?.length || 0
      }`
    );
  }

  if (currentStageTracking) {
    // Update today's daily_log based on the (possibly newly generated) daily_checklist
    const todayDate = getVietnamToday();
    const today = todayDate.toISOString().split("T")[0];

    console.log(
      `üîç Checking daily_logs for stage ${notebook.current_stage} on ${today}`
    );

    if (!currentStageTracking.daily_logs) currentStageTracking.daily_logs = [];

    let dailyLog = currentStageTracking.daily_logs.find(
      (log) => log.date?.toISOString().split("T")[0] === today
    );

    if (!dailyLog) {
      dailyLog = { date: todayDate, daily_progress: 0 };
      currentStageTracking.daily_logs.push(dailyLog);
      console.log(`‚ûï Created new daily_log for ${today}`);
    } else {
      console.log(
        `‚úÖ Found existing daily_log for ${today}: ${dailyLog.daily_progress}%`
      );
    }

    const todayTasks = notebook.daily_checklist || [];
    const completedTodayTasks = todayTasks.filter((t) => t.is_completed).length;
    const totalTodayTasks = todayTasks.length;

    if (totalTodayTasks > 0) {
      dailyLog.daily_progress = Math.round(
        (completedTodayTasks / totalTodayTasks) * 100
      );
      console.log(
        `üìÖ Daily progress for ${today}: ${dailyLog.daily_progress}% (${completedTodayTasks}/${totalTodayTasks})`
      );
    }
  } else {
    console.warn(
      `‚ö†Ô∏è No currentStageTracking found for stage ${notebook.current_stage}`
    );
  }

  if (currentStageTracking && notebook.template_id) {
    const stageCompletion = await notebook.getCurrentStageCompletion();
    console.log(`üéØ Current stage completion: ${stageCompletion}%`);

    // ‚ö†Ô∏è Kh√¥ng t·ª± ƒë·ªông mark stage completed ch·ªâ d·ª±a v√†o tasks
    // Stage ch·ªâ ƒë∆∞·ª£c mark completed khi ho√†n th√†nh observations ·ªü updateStageObservation
    console.log(
      `‚ÑπÔ∏è Stage completion: ${stageCompletion}% (waiting for observations to complete stage)`
    );
  }

  await notebook.save();

  return notebook;
};

/**
 * L·∫•y t·∫•t c·∫£ observations c·ªßa stage hi·ªán t·∫°i
 * CH·ªà tr·∫£ v·ªÅ observations n·∫øu ƒëang ·ªü ng√†y cu·ªëi c·ªßa giai ƒëo·∫°n
 */
const getCurrentStageObservations = async (notebookId) => {
  const notebook = await Notebook.findById(notebookId).populate("template_id");

  if (!notebook || !notebook.template_id) {
    return [];
  }

  const template = notebook.template_id;
  const currentStage = template.stages.find(
    (s) => s.stage_number === notebook.current_stage
  );

  if (!currentStage) {
    return [];
  }

  // Ki·ªÉm tra xem c√≥ ph·∫£i ng√†y cu·ªëi c·ªßa giai ƒëo·∫°n kh√¥ng
  const currentDay = notebook.current_day || 1;
  const isLastDayOfStage = currentDay === currentStage.day_end;

  // N·∫øu stage ƒë√£ completed th√¨ kh√¥ng tr·∫£ v·ªÅ observation required n·ªØa
  const stageTracking = notebook.stages_tracking.find(
    (s) => s.stage_number === notebook.current_stage
  );
  if (stageTracking && stageTracking.status === "completed") {
    // Tr·∫£ v·ªÅ danh s√°ch observation ƒë√£ ghi nh·∫≠n (c√≥ value=true)
    return (
      stageTracking.observations?.map((obs) => ({
        key: obs.key,
        value: obs.value,
        observed_at: obs.observed_at,
        completed: true,
      })) || []
    );
  }
  // CH·ªà tr·∫£ v·ªÅ observations n·∫øu ƒëang ·ªü ng√†y cu·ªëi
  if (!isLastDayOfStage) {
    return [];
  }
  // Tr·∫£ v·ªÅ danh s√°ch observation required, k√®m tr·∫°ng th√°i ƒë√£ ho√†n th√†nh n·∫øu c√≥
  return (currentStage?.observation_required || []).map((obsReq) => {
    const found = stageTracking?.observations?.find(
      (o) => o.key === obsReq.key
    );
    return {
      ...obsReq,
      value: found?.value ?? false,
      observed_at: found?.observed_at ?? null,
      completed: !!found?.value,
    };
  });
};

/**
 * C·∫≠p nh·∫≠t observation cho stage hi·ªán t·∫°i
 */
export const updateStageObservation = async (
  notebookId,
  observationKey,
  value
) => {
  const notebook = await Notebook.findById(notebookId).populate("template_id");

  if (!notebook) {
    throw new AppError("Kh√¥ng t√¨m th·∫•y nh·∫≠t k√Ω", 404);
  }

  const stageTracking = notebook.stages_tracking.find(
    (s) => s.stage_number === notebook.current_stage
  );

  if (!stageTracking) {
    throw new AppError("Kh√¥ng t√¨m th·∫•y stage tracking", 404);
  }

  // ‚úÖ KI·ªÇM TRA: T·∫•t c·∫£ tasks h√¥m nay v√† overdue tasks ph·∫£i ho√†n th√†nh tr∆∞·ªõc khi check observations
  const todayTasks = notebook.daily_checklist || [];
  const incompleteTodayTasks = todayTasks.filter((t) => !t.is_completed);

  const overdueTasks = stageTracking.overdue_tasks || [];
  const pendingOverdue = overdueTasks.filter(
    (t) => t.status === "overdue" || t.status === "pending"
  );

  if (incompleteTodayTasks.length > 0 || pendingOverdue.length > 0) {
    let parts = [];
    if (pendingOverdue.length > 0) {
      parts.push(`${pendingOverdue.length} c√¥ng vi·ªác tr·ªÖ c·∫ßn ho√†n th√†nh`);
    }
    if (incompleteTodayTasks.length > 0) {
      parts.push(
        `${incompleteTodayTasks.length} c√¥ng vi·ªác h√¥m nay ch∆∞a ho√†n th√†nh`
      );
    }

    const message = `Vui l√≤ng ho√†n th√†nh: ${parts.join(
      " v√† "
    )} tr∆∞·ªõc khi ki·ªÉm tra ƒëi·ªÅu ki·ªán quan s√°t.`;
    throw new AppError(message, 400, "TASKS_NOT_COMPLETED");
  }

  const existingObs = stageTracking.observations.find(
    (o) => o.key === observationKey
  );

  if (existingObs) {
    existingObs.value = value;
    existingObs.observed_at = new Date();
  } else {
    stageTracking.observations.push({
      key: observationKey,
      value: value,
      observed_at: new Date(),
    });
  }

  await notebook.save();

  // ‚úÖ Ki·ªÉm tra xem t·∫•t c·∫£ observations ƒë√£ ho√†n th√†nh ch∆∞a
  if (notebook.template_id && notebook.template_id.stages) {
    const currentTemplateStage = notebook.template_id.stages.find(
      (s) => s.stage_number === notebook.current_stage
    );

    if (currentTemplateStage && currentTemplateStage.observation_required) {
      const requiredObservations = currentTemplateStage.observation_required;
      const completedObservations = stageTracking.observations.filter(
        (obs) => obs.value === true
      );

      console.log(
        `üìä Observations: ${completedObservations.length}/${requiredObservations.length} completed`
      );

      // N·∫øu t·∫•t c·∫£ observations b·∫Øt bu·ªôc ƒë√£ ho√†n th√†nh (value = true)
      if (completedObservations.length >= requiredObservations.length) {
        console.log(
          `‚úÖ All observations completed for stage ${notebook.current_stage}`
        );

        // ƒê√°nh d·∫•u stage hi·ªán t·∫°i ho√†n th√†nh (s·ª≠ d·ª•ng template-based end date)
        const currentTemplateStage = notebook.template_id.stages.find(
          (s) => s.stage_number === notebook.current_stage
        );
        stageTracking.completed_at = currentTemplateStage
          ? getStageEndDate(notebook.planted_date, currentTemplateStage.day_end)
          : new Date();
        stageTracking.status = "completed";

        // ‚úÖ C·∫¨P NH·∫¨T PROGRESS - Ch·ªâ c·∫≠p nh·∫≠t ·ªü ƒë√¢y khi ho√†n th√†nh observations
        // ƒê√¢y l√† N∆†I DUY NH·∫§T ƒë∆∞·ª£c ph√©p c·∫≠p nh·∫≠t progress c·ªßa to√†n b·ªô notebook
        await notebook.updateProgress(notebook.template_id.stages);
        console.log(`üå± Plant progress updated: ${notebook.progress}%`);

        // üìÖ ƒê√ÅNH D·∫§U CHO CHUY·ªÇN STAGE V√ÄO NG√ÄY H√îM SAU
        // Kh√¥ng chuy·ªÉn stage ngay, ch·ªâ ƒë√°nh d·∫•u pending_transition
        stageTracking.pending_transition = true;
        stageTracking.transition_date = getVietnamToday(); // Ng√†y ho√†n th√†nh observations

        console.log(
          `üïí Stage ${notebook.current_stage} marked as pending transition. Will switch to next stage tomorrow.`
        );

        await notebook.save();
      } else {
        await notebook.save();
      }
    } else {
      await notebook.save();
    }
  }

  return notebook;
};

/**
 * T√≠nh stage hi·ªán t·∫°i d·ª±a tr√™n s·ªë ng√†y ƒë√£ tr·ªìng
 */
const calculateCurrentStage = async (notebookId) => {
  const notebook = await Notebook.findById(notebookId).populate("template_id");

  if (!notebook || !notebook.template_id) {
    return null;
  }

  const template = notebook.template_id;
  const daysPlanted = notebook.current_day;

  const stageInfo = template.getStageByDay(daysPlanted);

  if (stageInfo && stageInfo.stage_number !== notebook.current_stage) {
    await updateCurrentStage(notebookId, stageInfo.stage_number);
  }

  return stageInfo;
};

// ==========================================
// CONTROLLER EXPORTS
// ==========================================

// üìò L·∫•y t·∫•t c·∫£ notebook c·ªßa user
export const getAllByUser = asyncHandler(async (req, res) => {
  const notebooks = await Notebook.find({
    user_id: req.user.id,
    status: { $ne: "deleted" },
  })
    .populate("guide_id", "title category difficulty estimatedTime")
    .populate("template_id", "template_name plant_group status stages")
    .sort({ createdAt: -1 });

  return ok(
    res,
    notebooks,
    {
      count: notebooks.length,
      timezone: "Asia/Ho_Chi_Minh (UTC+7)",
    },
    "Fetched all notebooks successfully"
  );
});

// üìó L·∫•y chi ti·∫øt notebook theo ID
export const getNotebookById = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const notebook = await Notebook.findOne({
    _id: id,
    user_id: req.user.id,
    status: { $ne: "deleted" },
  })
    .populate(
      "guide_id",
      "title category difficulty estimatedTime description steps"
    )
    .populate("template_id");

  if (!notebook) {
    return res
      .status(404)
      .json({ success: false, message: "Notebook not found" });
  }

  // Th√™m stage_completion % v√†o response (now async)
  const notebookData = notebook.toObject();
  notebookData.stage_completion = await notebook.getCurrentStageCompletion();

  return ok(
    res,
    notebookData,
    { timezone: "Asia/Ho_Chi_Minh (UTC+7)" },
    "Fetched notebook detail successfully"
  );
});

// üìù T·∫°o m·ªõi notebook
export const createNotebook = asyncHandler(async (req, res) => {
  const { notebook_name, guide_id, description, cover_image, planted_date } =
    req.body;

  let plant_type = req.body.plant_type;
  let plant_group = null;
  let autoFoundTemplate = null;

  // ‚úÖ FLOW T·ª∞ ƒê·ªòNG: Guide ‚Üí plant_group ‚Üí Template
  if (guide_id) {
    const guide = await Guide.findById(guide_id);
    if (!guide) {
      return res
        .status(404)
        .json({ success: false, message: "Guide not found" });
    }

    // L·∫•y plant_name v√† plant_group t·ª´ Guide
    plant_type = guide.plant_name || guide.title;
    plant_group = guide.plant_group;

    console.log(`üìó Guide found: ${guide.plant_name} ‚Üí Group: ${plant_group}`);

    // T·ª± ƒë·ªông t√¨m template d·ª±a tr√™n plant_group
    if (plant_group && plant_group !== "other") {
      autoFoundTemplate = await PlantTemplate.findOne({
        plant_group: plant_group,
        status: "active",
      }).sort({ usage_count: -1 }); // L·∫•y template ƒë∆∞·ª£c d√πng nhi·ªÅu nh·∫•t

      if (autoFoundTemplate) {
        console.log(
          `‚úÖ Auto-found template: ${autoFoundTemplate.template_name}`
        );
      } else {
        console.log(`‚ö†Ô∏è No active template found for group: ${plant_group}`);
      }
    }
  }

  if (!plant_type) {
    return res.status(400).json({
      success: false,
      message:
        "plant_type is required. Provide either guide_id or plant_type directly.",
    });
  }

  // T·∫°o notebook v·ªõi plant_group
  // Normalize planted_date to Vietnam day-start to avoid timezone shifts.
  // Use parseVietnamDate so date-only strings (e.g. '2025-11-24') are
  // interpreted as Vietnam local dates instead of UTC-midnight.
  const normalizedPlantedDate = planted_date
    ? parseVietnamDate(planted_date)
    : getVietnamToday();

  const newNotebook = await Notebook.create({
    user_id: req.user.id,
    notebook_name,
    guide_id: guide_id || undefined,
    plant_type,
    plant_group: plant_group || "other",
    description,
    cover_image,
    planted_date: normalizedPlantedDate,
  });

  // ‚úÖ T·ª∞ ƒê·ªòNG G√ÅN TEMPLATE n·∫øu t√¨m ƒë∆∞·ª£c
  if (autoFoundTemplate) {
    try {
      const notebookWithTemplate = await assignTemplateToNotebook(
        newNotebook._id,
        autoFoundTemplate._id
      );

      console.log(
        `üéâ Template assigned successfully to notebook ${newNotebook._id}`
      );

      return created(
        res,
        notebookWithTemplate,
        `Notebook created with template: ${autoFoundTemplate.template_name}`
      );
    } catch (error) {
      console.error("‚ùå Error assigning template:", error);
      // V·∫´n tr·∫£ v·ªÅ notebook ƒë√£ t·∫°o, ch·ªâ kh√¥ng c√≥ template
      return created(
        res,
        newNotebook,
        "Notebook created but template assignment failed"
      );
    }
  }

  // Kh√¥ng t√¨m ƒë∆∞·ª£c template ‚Üí tr·∫£ v·ªÅ notebook th∆∞·ªùng
  return created(
    res,
    newNotebook,
    "Notebook created successfully (no template found)"
  );
});

// üîÑ C·∫≠p nh·∫≠t notebook
export const updateNotebook = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const notebook = await Notebook.findOneAndUpdate(
    { _id: id, user_id: req.user.id },
    req.body,
    { new: true }
  );

  if (!notebook) {
    return res
      .status(404)
      .json({ success: false, message: "Notebook not found" });
  }

  return ok(res, notebook, null, "Notebook updated successfully");
});

// üóëÔ∏è X√≥a m·ªÅm notebook (soft delete - ƒë√°nh d·∫•u deleted)
export const deleteNotebook = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const notebook = await Notebook.findOneAndUpdate(
    { _id: id, user_id: req.user.id },
    { status: "deleted", deletedAt: new Date() },
    { new: true }
  );

  if (!notebook) {
    return res
      .status(404)
      .json({ success: false, message: "Notebook not found" });
  }

  return ok(
    res,
    { id: notebook._id, status: notebook.status },
    null,
    "Notebook deleted successfully"
  );
});

// ‚ôªÔ∏è Kh√¥i ph·ª•c notebook ƒë√£ x√≥a
export const restoreNotebook = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const notebook = await Notebook.findOneAndUpdate(
    { _id: id, user_id: req.user.id, status: "deleted" },
    { status: "active", $unset: { deletedAt: "" } },
    { new: true }
  );

  if (!notebook) {
    return res
      .status(404)
      .json({ success: false, message: "Notebook not found or not deleted" });
  }

  return ok(
    res,
    { id: notebook._id, status: notebook.status },
    null,
    "Notebook restored successfully"
  );
});

// üóëÔ∏è L·∫•y danh s√°ch notebook ƒë√£ x√≥a
export const getDeletedNotebooks = asyncHandler(async (req, res) => {
  const notebooks = await Notebook.find({
    user_id: req.user.id,
    status: "deleted",
  })
    .populate("guide_id", "title category")
    .populate("template_id", "template_name plant_group")
    .sort({ deletedAt: -1 });

  return ok(
    res,
    notebooks,
    { count: notebooks.length },
    "Deleted notebooks fetched successfully"
  );
});

// üíÄ X√≥a vƒ©nh vi·ªÖn notebook (hard delete)
export const permanentDeleteNotebook = asyncHandler(async (req, res) => {
  const { id } = req.params;

  const notebook = await Notebook.findOneAndDelete({
    _id: id,
    user_id: req.user.id,
    status: "deleted", // Ch·ªâ cho ph√©p x√≥a vƒ©nh vi·ªÖn notebook ƒë√£ ·ªü tr·∫°ng th√°i deleted
  });

  if (!notebook) {
    return res.status(404).json({
      success: false,
      message: "Notebook not found or not in deleted status",
    });
  }

  return ok(res, { id: notebook._id }, null, "Notebook permanently deleted");
});

// üîç T√¨m ki·∫øm notebook theo t·ª´ kh√≥a
export const searchNotebooks = asyncHandler(async (req, res) => {
  const { keyword } = req.query;

  if (!keyword) {
    return res
      .status(400)
      .json({ success: false, message: "Keyword is required" });
  }

  const notebooks = await Notebook.find({
    user_id: req.user.id,
    status: { $ne: "deleted" },
    $or: [
      { notebook_name: { $regex: keyword, $options: "i" } },
      { plant_type: { $regex: keyword, $options: "i" } },
      { description: { $regex: keyword, $options: "i" } },
    ],
  })
    .populate("guide_id", "title category difficulty")
    .populate("template_id", "template_name plant_group")
    .sort({ createdAt: -1 });

  const meta = { count: notebooks.length, keyword };
  return ok(res, notebooks, meta, "Search results fetched successfully");
});

// üß© L·ªçc notebook theo ti√™u ch√≠
export const filterNotebooks = asyncHandler(async (req, res) => {
  const { plant_type, status, min_progress, max_progress, sort_by, order } =
    req.query;

  const filter = {
    user_id: req.user.id,
    status: { $ne: "deleted" },
  };

  if (plant_type) filter.plant_type = { $regex: plant_type, $options: "i" };
  if (status && ["active", "archived"].includes(status)) filter.status = status;
  if (min_progress !== undefined || max_progress !== undefined) {
    filter.progress = {};
    if (min_progress !== undefined)
      filter.progress.$gte = parseInt(min_progress);
    if (max_progress !== undefined)
      filter.progress.$lte = parseInt(max_progress);
  }

  let sortOption = { createdAt: -1 };
  if (sort_by) {
    const sortOrder = order === "asc" ? 1 : -1;
    switch (sort_by) {
      case "name":
        sortOption = { notebook_name: sortOrder };
        break;
      case "progress":
        sortOption = { progress: sortOrder };
        break;
      case "created":
        sortOption = { createdAt: sortOrder };
        break;
      case "updated":
        sortOption = { updatedAt: sortOrder };
        break;
    }
  }

  const notebooks = await Notebook.find(filter)
    .populate("guide_id", "title category difficulty estimatedTime")
    .populate("template_id", "template_name plant_group status")
    .sort(sortOption);

  const meta = {
    count: notebooks.length,
    filter: {
      plant_type: plant_type || "all",
      status: status || "all except deleted",
      progress_range: { min: min_progress || 0, max: max_progress || 100 },
      sort_by: sort_by || "created",
      order: order || "desc",
    },
  };

  return ok(res, notebooks, meta, "Filtered notebooks fetched successfully");
});

// üñºÔ∏è Th√™m ·∫£nh v√†o notebook
export const addImage = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { image_url } = req.body;

  if (!image_url) {
    return res
      .status(400)
      .json({ success: false, message: "image_url is required" });
  }

  const notebook = await Notebook.findOne({
    _id: id,
    user_id: req.user.id,
    status: { $ne: "deleted" },
  });

  if (!notebook) {
    return res
      .status(404)
      .json({ success: false, message: "Notebook not found" });
  }

  notebook.images.push(image_url);
  await notebook.save();

  return ok(
    res,
    { images: notebook.images, total: notebook.images.length },
    null,
    "Image added successfully"
  );
});

// üßπ X√≥a ·∫£nh kh·ªèi notebook
export const removeImage = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { image_url } = req.body;

  if (!image_url) {
    return res
      .status(400)
      .json({ success: false, message: "image_url is required" });
  }

  const notebook = await Notebook.findOne({
    _id: id,
    user_id: req.user.id,
    status: { $ne: "deleted" },
  });

  if (!notebook) {
    return res
      .status(404)
      .json({ success: false, message: "Notebook not found" });
  }

  notebook.images = notebook.images.filter((img) => img !== image_url);
  await notebook.save();

  return ok(
    res,
    { images: notebook.images, total: notebook.images.length },
    null,
    "Image removed successfully"
  );
});

// üå± L·∫•y template ph√π h·ª£p cho notebook
export const getNotebookTemplate = asyncHandler(async (req, res) => {
  const { id } = req.params;

  const template = await getTemplateForNotebook(id);

  if (!template) {
    return res
      .status(404)
      .json({ success: false, message: "No suitable template found" });
  }

  return ok(res, template, null, "Template fetched successfully");
});

// üìå G√°n template cho notebook
export const assignTemplate = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { template_id } = req.body;

  if (!template_id) {
    return res
      .status(400)
      .json({ success: false, message: "template_id is required" });
  }

  const notebook = await assignTemplateToNotebook(id, template_id);

  return ok(res, notebook, null, "Template assigned successfully");
});

// üìä L·∫•y timeline c·ªßa notebook
export const getNotebookTimeline = asyncHandler(async (req, res) => {
  const { id } = req.params;

  // Validate ID
  if (!id || id === "undefined" || id === "null") {
    return res.status(400).json({
      success: false,
      message: "Invalid notebook ID",
    });
  }

  const notebook = await Notebook.findById(id).populate("template_id");

  if (!notebook || !notebook.template_id) {
    return ok(
      res,
      null,
      { hasTemplate: false },
      "Notebook ch∆∞a c√≥ template. Vui l√≤ng g√°n template ƒë·ªÉ xem timeline."
    );
  }

  const template = notebook.template_id;

  const timeline = notebook.stages_tracking.map((tracking) => {
    const templateStage = template.stages.find(
      (s) => s.stage_number === tracking.stage_number
    );

    return {
      stage_number: tracking.stage_number,
      stage_name: tracking.stage_name,
      started_at: tracking.started_at,
      completed_at: tracking.completed_at,
      is_current: tracking.is_current,
      duration_days: templateStage
        ? templateStage.day_end - templateStage.day_start + 1
        : null,
      start_day: templateStage ? templateStage.day_start : null,
      end_day: templateStage ? templateStage.day_end : null,
      observations: tracking.observations,
    };
  });

  // Th√™m ng√†y hi·ªÉn th·ªã (d·ª±a tr√™n planted_date + template day_start/day_end)
  const timelineWithDates = timeline.map((t) => {
    const templateStage = template.stages.find(
      (s) => s.stage_number === t.stage_number
    );

    if (!templateStage) return t;

    const stageStart = getStageStartDate(
      notebook.planted_date,
      templateStage.day_start
    );
    const stageEnd = getStageEndDate(
      notebook.planted_date,
      templateStage.day_end
    );

    return {
      ...t,
      stage_start_date: formatVietnamDate(stageStart),
      stage_end_date: formatVietnamDate(stageEnd),
    };
  });

  const timelineData = {
    planted_date: notebook.planted_date,
    current_day: notebook.current_day,
    progress: notebook.progress,
    total_days: template.total_days,
    timeline: timelineWithDates,
  };

  return ok(
    res,
    timelineData,
    { timezone: "Asia/Ho_Chi_Minh (UTC+7)" },
    "Timeline fetched successfully"
  );
});

// ‚úÖ L·∫•y daily checklist
export const getDailyChecklist = asyncHandler(async (req, res) => {
  const { id } = req.params;

  // Validate ID
  if (!id || id === "undefined" || id === "null") {
    return res.status(400).json({
      success: false,
      message: "Invalid notebook ID",
    });
  }

  const checklist = await generateDailyChecklist(id);

  // ‚úÖ Return 200 with empty array instead of 404 for better UX
  if (!checklist) {
    return ok(
      res,
      [],
      {
        hasTemplate: false,
        timezone: "Asia/Ho_Chi_Minh (UTC+7)",
      },
      "Notebook ch∆∞a c√≥ template. Vui l√≤ng g√°n template ƒë·ªÉ t·∫°o checklist."
    );
  }

  // Ki·ªÉm tra xem stage c√≥ ƒëang pending transition kh√¥ng
  const notebook = await Notebook.findById(id);
  const currentStageTracking = notebook?.stages_tracking?.find(
    (s) => s.stage_number === notebook.current_stage
  );

  const isPendingTransition = currentStageTracking?.pending_transition === true;

  return ok(
    res,
    checklist,
    {
      timezone: "Asia/Ho_Chi_Minh (UTC+7)",
      pending_transition: isPendingTransition,
      transition_message: isPendingTransition
        ? "C√¥ng vi·ªác m·ªõi s·∫Ω xu·∫•t hi·ªán v√†o giai ƒëo·∫°n m·ªõi v√†o ng√†y mai"
        : null,
    },
    "Daily checklist fetched successfully"
  );
});

// ‚úîÔ∏è ƒê√°nh d·∫•u ho√†n th√†nh task
export const completeTask = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { task_name } = req.body;

  if (!task_name) {
    return res
      .status(400)
      .json({ success: false, message: "task_name is required" });
  }

  const notebook = await completeChecklistTask(id, task_name);

  return ok(res, notebook.daily_checklist, null, "Task completed successfully");
});

// üîÑ C·∫≠p nh·∫≠t stage hi·ªán t·∫°i
export const updateStage = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { stage_number } = req.body;

  if (!stage_number) {
    return res
      .status(400)
      .json({ success: false, message: "stage_number is required" });
  }

  const notebook = await updateCurrentStage(id, stage_number);

  return ok(res, notebook, null, "Stage updated successfully");
});

// üëÅÔ∏è L·∫•y observations c·ªßa stage hi·ªán t·∫°i
export const getCurrentObservations = asyncHandler(async (req, res) => {
  const { id } = req.params;

  const observations = await getCurrentStageObservations(id);

  return ok(
    res,
    observations,
    null,
    "Current stage observations fetched successfully"
  );
});

// üìù C·∫≠p nh·∫≠t observation
export const updateObservation = asyncHandler(async (req, res) => {
  const { id } = req.params;
  // Accept multiple possible key names from different frontends
  const { observation_key, value } = req.body;
  const altKey =
    req.body.key || req.body.observationKey || req.body.observation_key;

  // Log request body for easier debugging in development
  if (process.env.NODE_ENV !== "production") {
    console.log("üîî updateObservation called", {
      notebookId: id,
      body: req.body,
    });
  }

  if (!altKey || value === undefined) {
    return res.status(400).json({
      success: false,
      message: "observation_key and value are required",
    });
  }

  // Normalize to observation_key variable
  const observationKey = altKey;

  const notebook = await updateStageObservation(id, observationKey, value);

  // Ki·ªÉm tra xem c√≥ chuy·ªÉn stage kh√¥ng
  const currentStage = notebook.stages_tracking.find((s) => s.is_current);
  const previousStageNumber = req.body._previousStage || notebook.current_stage;

  if (currentStage && currentStage.stage_number > previousStageNumber) {
    return ok(
      res,
      notebook,
      {
        auto_transitioned: true,
        new_stage: currentStage.stage_number,
        stage_name: currentStage.stage_name,
      },
      `‚úÖ ƒê√£ ho√†n th√†nh t·∫•t c·∫£ ƒëi·ªÅu ki·ªán quan s√°t! T·ª± ƒë·ªông chuy·ªÉn sang ${currentStage.stage_name}.`
    );
  }

  return ok(res, notebook, null, "Observation updated successfully");
});

// üîç T√≠nh stage hi·ªán t·∫°i d·ª±a tr√™n s·ªë ng√†y
export const calculateStage = asyncHandler(async (req, res) => {
  const { id } = req.params;

  const stageInfo = await calculateCurrentStage(id);

  if (!stageInfo) {
    return res
      .status(404)
      .json({ success: false, message: "Cannot calculate stage" });
  }

  return ok(res, stageInfo, null, "Stage calculated successfully");
});

// üîÑ Recalculate progress (debug endpoint)
export const recalculateProgress = asyncHandler(async (req, res) => {
  const { id } = req.params;

  const notebook = await Notebook.findOne({
    _id: id,
    user_id: req.user.id,
  }).populate("template_id");

  if (!notebook || !notebook.template_id) {
    return res.status(404).json({
      success: false,
      message: "Notebook not found or no template assigned",
    });
  }

  // Recalculate progress
  await notebook.updateProgress(notebook.template_id.stages);
  await notebook.save();

  const stageCompletion = await notebook.getCurrentStageCompletion();

  return ok(
    res,
    {
      progress: notebook.progress,
      stage_completion: stageCompletion,
      template_stages: notebook.template_id.stages.map((s) => ({
        stage_number: s.stage_number,
        name: s.name,
        weight:
          s.weight || Math.round(100 / notebook.template_id.stages.length),
      })),
      stages_tracking: notebook.stages_tracking.map((s) => ({
        stage_number: s.stage_number,
        stage_name: s.stage_name,
        is_current: s.is_current,
        completed: !!s.completed_at,
      })),
    },
    null,
    "Progress recalculated successfully"
  );
});

// üîß Migrate old notebooks to add completed_tasks field
export const migrateNotebooks = asyncHandler(async (req, res) => {
  const notebooks = await Notebook.find({
    user_id: req.user.id,
  }).populate("template_id");

  let migratedCount = 0;

  for (const notebook of notebooks) {
    let needsSave = false;

    // Check each stage_tracking
    for (const stageTracking of notebook.stages_tracking) {
      // If no completed_tasks, initialize empty array
      if (!stageTracking.completed_tasks) {
        stageTracking.completed_tasks = [];
        needsSave = true;
      }
    }

    if (needsSave) {
      await notebook.save();
      migratedCount++;
      console.log(
        `‚úÖ Migrated notebook: ${notebook.notebook_name} (${notebook._id})`
      );
    }
  }

  return ok(
    res,
    {
      total: notebooks.length,
      migrated: migratedCount,
      already_updated: notebooks.length - migratedCount,
    },
    null,
    `Migration complete! ${migratedCount} notebook(s) updated`
  );
});

// ==========================================
// STAGE MONITORING EXPORTS
// ==========================================

// üîç Ki·ªÉm tra m·ªôt notebook c·ª• th·ªÉ (manual trigger)
export const checkSingleNotebook = asyncHandler(async (req, res) => {
  const { id } = req.params;

  const notebook = await Notebook.findById(id).populate("template_id");

  if (!notebook) {
    return res.status(404).json({
      success: false,
      message: "Kh√¥ng t√¨m th·∫•y notebook",
    });
  }

  await checkNotebookStageStatus(notebook);

  return ok(
    res,
    {
      notebook_id: notebook._id,
      notebook_name: notebook.notebook_name,
      current_stage: notebook.current_stage,
      stages_tracking: notebook.stages_tracking.map((s) => ({
        stage_number: s.stage_number,
        stage_name: s.stage_name,
        status: s.status,
        missed_days: s.missed_days,
        is_current: s.is_current,
      })),
    },
    null,
    "Notebook stage status checked successfully"
  );
});

// üîÑ Monitor t·∫•t c·∫£ notebooks (admin/cron endpoint)
export const monitorAllNotebooks = asyncHandler(async (req, res) => {
  console.log("üîç B·∫Øt ƒë·∫ßu monitor t·∫•t c·∫£ notebooks...");

  try {
    const notebooks = await Notebook.find({
      status: "active",
      template_id: { $exists: true, $ne: null },
    }).populate("template_id");

    console.log(`üìä T√¨m th·∫•y ${notebooks.length} notebooks c·∫ßn ki·ªÉm tra`);

    for (const notebook of notebooks) {
      await checkNotebookStageStatus(notebook);
    }

    console.log("‚úÖ Ho√†n th√†nh monitor t·∫•t c·∫£ notebooks");

    return ok(
      res,
      {
        total_checked: notebooks.length,
        timestamp: new Date(),
      },
      null,
      "All notebooks monitored successfully"
    );
  } catch (error) {
    console.error("‚ùå L·ªói khi monitor notebooks:", error);
    return res.status(500).json({
      success: false,
      message: "Error monitoring notebooks",
      error: error.message,
    });
  }
});

// ==========================================
// DAILY STATUS & OVERDUE MANAGEMENT
// ==========================================

// üìÖ L·∫•y tr·∫°ng th√°i h√†ng ng√†y (tasks h√¥m nay + overdue summary)
export const getDailyStatus = asyncHandler(async (req, res) => {
  const { id } = req.params; // notebook_id

  const notebook = await Notebook.findOne({
    _id: id,
    user_id: req.user.id,
    status: { $ne: "deleted" },
  }).populate("template_id");

  if (!notebook) {
    return res.status(404).json({
      success: false,
      message: "Notebook not found",
    });
  }

  console.log(
    `üîî getDailyStatus called for notebook=${id} user=${req.user?.id}`
  );

  // T·∫°o checklist cho h√¥m nay (s·∫Ω t·ª± ƒë·ªông x·ª≠ l√Ω overdue n·∫øu sang ng√†y m·ªõi)
  await generateDailyChecklist(id);

  // Reload notebook sau khi generate
  const updatedNotebook = await Notebook.findById(id).populate("template_id");

  const currentStageTracking = updatedNotebook.stages_tracking.find(
    (s) => s.stage_number === updatedNotebook.current_stage
  );

  const today = getVietnamToday();
  const overdueSummary = currentStageTracking?.overdue_summary?.ready_to_notify
    ? {
        overdue_date: currentStageTracking.overdue_summary.date,
        overdue_count: currentStageTracking.overdue_summary.overdue_count,
      }
    : null;

  return ok(
    res,
    {
      today: today.toISOString().split("T")[0],
      current_day: updatedNotebook.current_day,
      tasks_today: updatedNotebook.daily_checklist,
      overdue_summary: overdueSummary,
    },
    { timezone: "Asia/Ho_Chi_Minh (UTC+7)" },
    "Daily status fetched successfully"
  );
});

// üóëÔ∏è B·ªè qua t·∫•t c·∫£ overdue tasks
export const skipOverdueTasks = asyncHandler(async (req, res) => {
  const { id } = req.params; // notebook_id

  const notebook = await Notebook.findOne({
    _id: id,
    user_id: req.user.id,
    status: { $ne: "deleted" },
  });

  if (!notebook) {
    return res.status(404).json({
      success: false,
      message: "Notebook not found",
    });
  }

  // ƒê√°nh d·∫•u t·∫•t c·∫£ overdue tasks (ƒë∆∞·ª£c l∆∞u trong stageTracking.overdue_tasks) = skipped
  const currentStageTracking = notebook.stages_tracking.find(
    (s) => s.stage_number === notebook.current_stage
  );

  if (!currentStageTracking || !currentStageTracking.overdue_tasks) {
    return ok(res, null, null, "No overdue tasks to skip");
  }

  const overdueTasks = currentStageTracking.overdue_tasks.filter(
    (t) => t.status === "overdue"
  );

  if (overdueTasks.length === 0) {
    return ok(res, null, null, "No overdue tasks to skip");
  }

  overdueTasks.forEach((t) => {
    t.status = "skipped";
    t.skipped_at = new Date();
  });

  // Reset overdue_summary notify flag
  if (currentStageTracking && currentStageTracking.overdue_summary) {
    currentStageTracking.overdue_summary.ready_to_notify = false;
    currentStageTracking.overdue_summary.notified_at = new Date();
  }

  await notebook.save();

  return ok(
    res,
    { skipped_count: overdueTasks.length },
    null,
    `${overdueTasks.length} overdue tasks skipped successfully`
  );
});

// ‚úÖ Ho√†n th√†nh m·ªôt overdue task (ho√†n th√†nh b√π)
export const completeOverdueTask = asyncHandler(async (req, res) => {
  const { id } = req.params; // notebook_id
  const { task_name } = req.body;

  if (!task_name) {
    return res
      .status(400)
      .json({ success: false, message: "task_name is required" });
  }

  const notebook = await Notebook.findOne({
    _id: id,
    user_id: req.user.id,
    status: { $ne: "deleted" },
  }).populate("template_id");

  if (!notebook) {
    return res
      .status(404)
      .json({ success: false, message: "Notebook not found" });
  }

  const currentStageTracking = notebook.stages_tracking.find(
    (s) => s.stage_number === notebook.current_stage
  );

  if (!currentStageTracking || !currentStageTracking.overdue_tasks) {
    return res
      .status(404)
      .json({ success: false, message: "No overdue tasks found" });
  }

  const task = currentStageTracking.overdue_tasks.find(
    (t) =>
      (t.task_name || "").trim() === (task_name || "").trim() &&
      t.status === "overdue"
  );

  if (!task) {
    return res
      .status(404)
      .json({ success: false, message: "Overdue task not found" });
  }

  // Mark as completed
  task.is_completed = true;
  // If this is a makeup for an original date, attribute the completion to the
  // original date so it counts toward that day's daily_log.
  task.completed_at = task.original_date
    ? new Date(task.original_date)
    : new Date();
  task.status = "completed";

  // Add to completed_tasks for tracking (if not already)
  if (!currentStageTracking.completed_tasks) {
    currentStageTracking.completed_tasks = [];
  }
  const alreadyCompleted = currentStageTracking.completed_tasks.some(
    (t) => t.task_name === task_name
  );
  if (!alreadyCompleted) {
    const completedAtForRecord = task.original_date
      ? new Date(task.original_date)
      : new Date();
    currentStageTracking.completed_tasks.push({
      task_name,
      completed_at: completedAtForRecord,
    });
  }

  // Persist the change to overdue_tasks (marking the task completed) before
  // regenerating the daily checklist so DB reflects the updated status.
  await notebook.save();

  // Update today's daily_log progress to include this makeup completion
  // Ensure we have today's checklist generated so progress math is correct
  await generateDailyChecklist(notebook._id);

  // Reload notebook to get updated daily_checklist
  const refreshedNotebook = await Notebook.findById(notebook._id).populate(
    "template_id"
  );

  const todayDate = getVietnamToday();
  const today = todayDate.toISOString().split("T")[0];

  const refreshedStageTracking = refreshedNotebook.stages_tracking.find(
    (s) => s.stage_number === refreshedNotebook.current_stage
  );

  if (!refreshedStageTracking.daily_logs)
    refreshedStageTracking.daily_logs = [];

  let dailyLog = refreshedStageTracking.daily_logs.find(
    (log) => log.date?.toISOString().split("T")[0] === today
  );

  if (!dailyLog) {
    dailyLog = { date: todayDate, daily_progress: 0 };
    refreshedStageTracking.daily_logs.push(dailyLog);
  }

  // Compute new daily progress: existing completed today + this makeup / total today tasks
  const todayTasks = refreshedNotebook.daily_checklist || [];
  const completedTodayTasks = todayTasks.filter((t) => t.is_completed).length;
  const totalTodayTasks = todayTasks.length || 0;

  if (totalTodayTasks > 0) {
    // Use the actual completed tasks count for today's progress. The previous
    // implementation added `+1` to account for the makeup completion, but
    // generateDailyChecklist already marks makeup tasks as completed for
    // today when `completed_at` is set to today. Adding +1 caused
    // overcounting or incorrect daily_logs when the task was present in
    // today's checklist. Use the straightforward ratio instead.
    dailyLog.daily_progress = Math.round(
      (completedTodayTasks / totalTodayTasks) * 100
    );
  } else {
    // If no daily tasks today, conservatively set a small progress increment (e.g., 10%)
    dailyLog.daily_progress = Math.min(
      100,
      (dailyLog.daily_progress || 0) + 10
    );
  }

  // ‚ö†Ô∏è KH√îNG c·∫≠p nh·∫≠t progress khi ho√†n th√†nh overdue task
  // Progress ch·ªâ ƒë∆∞·ª£c c·∫≠p nh·∫≠t khi ho√†n th√†nh t·∫•t c·∫£ observations ·ªü cu·ªëi giai ƒëo·∫°n
  console.log(
    `‚ÑπÔ∏è Overdue task completed. Progress will update only when observations are completed.`
  );
  // Recompute overdue_summary count and notify flag
  const remainingOverdue = currentStageTracking.overdue_tasks.filter(
    (t) => t.status === "overdue"
  ).length;

  if (!refreshedStageTracking.overdue_summary) {
    refreshedStageTracking.overdue_summary = {
      date: null,
      overdue_count: 0,
      ready_to_notify: false,
    };
  }

  refreshedStageTracking.overdue_summary.overdue_count = remainingOverdue;
  if (remainingOverdue === 0) {
    refreshedStageTracking.overdue_summary.ready_to_notify = false;
    refreshedStageTracking.overdue_summary.notified_at = new Date();
  }

  // Also update daily_log for the original date of the overdue task we just completed.
  try {
    const completedOverdue = refreshedStageTracking.overdue_tasks.find(
      (t) => t.task_name === task_name && t.status === "completed"
    );
    if (completedOverdue && completedOverdue.original_date) {
      const origKey = toVietnamMidnight(
        new Date(completedOverdue.original_date)
      )
        .toISOString()
        .split("T")[0];

      if (!refreshedStageTracking.daily_logs)
        refreshedStageTracking.daily_logs = [];

      let origLog = refreshedStageTracking.daily_logs.find(
        (log) =>
          toVietnamMidnight(new Date(log.date)).toISOString().split("T")[0] ===
          origKey
      );

      if (!origLog) {
        origLog = {
          date: toVietnamMidnight(new Date(completedOverdue.original_date)),
          daily_progress: 0,
        };
        refreshedStageTracking.daily_logs.push(origLog);
      }

      // Count overdue items that belong to this original date
      const related = refreshedStageTracking.overdue_tasks.filter(
        (ot) =>
          toVietnamMidnight(new Date(ot.original_date))
            .toISOString()
            .split("T")[0] === origKey
      );
      const completedCount = related.filter(
        (r) => r.status === "completed"
      ).length;
      const totalCount = related.length || 1;

      origLog.daily_progress = Math.round((completedCount / totalCount) * 100);
    }
  } catch (e) {
    console.warn(
      "Failed to update original-date daily_log for overdue completion:",
      e
    );
  }

  await refreshedNotebook.save();

  return ok(
    res,
    {
      notebook_id: refreshedNotebook._id,
      stage_completion: await refreshedNotebook.getCurrentStageCompletion(),
      progress: refreshedNotebook.progress,
    },
    null,
    "Overdue task completed successfully"
  );
});

// ‚úÖ Ho√†n th√†nh nhi·ªÅu overdue tasks c√πng l√∫c
export const completeOverdueTasksBulk = asyncHandler(async (req, res) => {
  const { id } = req.params; // notebook_id
  const { task_names } = req.body;

  if (!task_names || !Array.isArray(task_names) || task_names.length === 0) {
    return res
      .status(400)
      .json({ success: false, message: "task_names (array) is required" });
  }

  const notebook = await Notebook.findOne({
    _id: id,
    user_id: req.user.id,
    status: { $ne: "deleted" },
  }).populate("template_id");

  if (!notebook) {
    return res
      .status(404)
      .json({ success: false, message: "Notebook not found" });
  }

  const currentStageTracking = notebook.stages_tracking.find(
    (s) => s.stage_number === notebook.current_stage
  );

  if (!currentStageTracking || !currentStageTracking.overdue_tasks) {
    return res
      .status(404)
      .json({ success: false, message: "No overdue tasks found" });
  }

  const toComplete = task_names.map((name) => name.trim());
  const completedNow = [];

  toComplete.forEach((taskName) => {
    const task = currentStageTracking.overdue_tasks.find(
      (t) =>
        (t.task_name || "").trim() === (taskName || "").trim() &&
        t.status === "overdue"
    );
    if (task) {
      task.is_completed = true;
      task.completed_at = task.original_date
        ? new Date(task.original_date)
        : new Date();
      task.status = "completed";

      if (!currentStageTracking.completed_tasks)
        currentStageTracking.completed_tasks = [];
      const already = currentStageTracking.completed_tasks.some(
        (t) => t.task_name === taskName
      );
      if (!already) {
        const completedAtForRecord = task.original_date
          ? new Date(task.original_date)
          : new Date();
        currentStageTracking.completed_tasks.push({
          task_name: taskName,
          completed_at: completedAtForRecord,
        });
      }

      completedNow.push(taskName);
    }
  });
  // Persist changes to the notebook (marking overdue tasks completed)
  await notebook.save();

  // Regenerate checklist once
  await generateDailyChecklist(notebook._id);

  // Reload notebook
  const refreshedNotebook = await Notebook.findById(notebook._id).populate(
    "template_id"
  );

  const todayDate = getVietnamToday();
  const today = todayDate.toISOString().split("T")[0];

  const refreshedStageTracking = refreshedNotebook.stages_tracking.find(
    (s) => s.stage_number === refreshedNotebook.current_stage
  );

  if (!refreshedStageTracking.daily_logs)
    refreshedStageTracking.daily_logs = [];

  let dailyLog = refreshedStageTracking.daily_logs.find(
    (log) => log.date?.toISOString().split("T")[0] === today
  );
  if (!dailyLog) {
    dailyLog = { date: todayDate, daily_progress: 0 };
    refreshedStageTracking.daily_logs.push(dailyLog);
  }

  const todayTasks = refreshedNotebook.daily_checklist || [];
  const completedTodayTasks = todayTasks.filter((t) => t.is_completed).length;
  const totalTodayTasks = todayTasks.length || 0;

  if (totalTodayTasks > 0) {
    dailyLog.daily_progress = Math.round(
      (completedTodayTasks / totalTodayTasks) * 100
    );
  }

  // ‚ö†Ô∏è KH√îNG c·∫≠p nh·∫≠t progress khi ho√†n th√†nh bulk overdue tasks
  // Progress ch·ªâ ƒë∆∞·ª£c c·∫≠p nh·∫≠t khi ho√†n th√†nh observations ·ªü cu·ªëi giai ƒëo·∫°n
  console.log(
    `‚ÑπÔ∏è ${completedNow} overdue tasks completed. Progress will update only when observations are completed.`
  );

  // Recompute overdue_summary
  const remainingOverdue = currentStageTracking.overdue_tasks.filter(
    (t) => t.status === "overdue"
  ).length;
  if (!refreshedStageTracking.overdue_summary)
    refreshedStageTracking.overdue_summary = {
      date: null,
      overdue_count: 0,
      ready_to_notify: false,
    };
  refreshedStageTracking.overdue_summary.overdue_count = remainingOverdue;
  if (remainingOverdue === 0) {
    refreshedStageTracking.overdue_summary.ready_to_notify = false;
    refreshedStageTracking.overdue_summary.notified_at = new Date();
  }

  await refreshedNotebook.save();

  return ok(
    res,
    {
      notebook_id: refreshedNotebook._id,
      completed: completedNow,
      stage_completion: await refreshedNotebook.getCurrentStageCompletion(),
      progress: refreshedNotebook.progress,
    },
    null,
    "Bulk overdue tasks completed successfully"
  );
});

// üìã L·∫•y chi ti·∫øt overdue tasks
export const getOverdueDetail = asyncHandler(async (req, res) => {
  const { id } = req.params; // notebook_id

  const notebook = await Notebook.findOne({
    _id: id,
    user_id: req.user.id,
    status: { $ne: "deleted" },
  });

  if (!notebook) {
    return res.status(404).json({
      success: false,
      message: "Notebook not found",
    });
  }

  console.log(
    `üîî getOverdueDetail called for notebook=${id} user=${req.user?.id}`
  );

  const currentStageTracking = notebook.stages_tracking.find(
    (s) => s.stage_number === notebook.current_stage
  );

  const allOverdueTasks = currentStageTracking?.overdue_tasks || [];
  // Return only tasks that are still in 'overdue' status. Completed/skipped
  // entries remain in the array for history but should not be counted as active overdue.
  const activeOverdueTasks = allOverdueTasks.filter(
    (t) => t.status === "overdue"
  );

  console.log(
    `üîç Overdue tasks for notebook=${id} stage=${notebook.current_stage}: persisted=${allOverdueTasks.length} active=${activeOverdueTasks.length}`
  );

  return ok(
    res,
    {
      overdue_date: currentStageTracking?.overdue_summary?.date || null,
      overdue_count: activeOverdueTasks.length,
      overdue_tasks: activeOverdueTasks,
    },
    null,
    "Overdue tasks detail fetched successfully"
  );
});

// =====================
// Notebook statistics
// =====================
export const getStats = asyncHandler(async (req, res) => {
  const userId = req.user?.id;

  const match = { status: { $ne: "deleted" } };
  if (userId) match.user_id = new mongoose.Types.ObjectId(userId);

  // By type
  const byTypeAgg = await Notebook.aggregate([
    { $match: match },
    { $group: { _id: "$plant_type", count: { $sum: 1 } } },
    { $sort: { count: -1 } },
  ]);

  // By group
  const byGroupAgg = await Notebook.aggregate([
    { $match: match },
    { $group: { _id: "$plant_group", count: { $sum: 1 } } },
    { $sort: { count: -1 } },
  ]);

  // Average progress
  const progressAgg = await Notebook.aggregate([
    { $match: match },
    { $group: { _id: null, avgProgress: { $avg: "$progress" } } },
  ]);

  const avgProgress = progressAgg[0]?.avgProgress ?? 0;

  // Progress distribution
  const distributionAgg = await Notebook.aggregate([
    { $match: match },
    {
      $bucket: {
        groupBy: "$progress",
        boundaries: [0, 25, 50, 75, 100, 101],
        default: "unknown",
        output: { count: { $sum: 1 } },
      },
    },
  ]);

  const progressDistribution = {
    "0-25": 0,
    "25-50": 0,
    "50-75": 0,
    "75-100": 0,
  };
  distributionAgg.forEach((b) => {
    const key = b._id;
    if (key === 0) progressDistribution["0-25"] = b.count;
    else if (key === 25) progressDistribution["25-50"] = b.count;
    else if (key === 50) progressDistribution["50-75"] = b.count;
    else if (key === 75) progressDistribution["75-100"] = b.count;
  });

  // Most popular type
  const mostPopularType = byTypeAgg.length > 0 ? byTypeAgg[0]._id : null;

  // Average grow days (planted_date -> max completed_at)
  const avgGrowAgg = await Notebook.aggregate([
    { $match: match },
    {
      $addFields: { maxCompletedAt: { $max: "$stages_tracking.completed_at" } },
    },
    {
      $match: {
        planted_date: { $exists: true, $ne: null },
        maxCompletedAt: { $exists: true, $ne: null },
      },
    },
    {
      $project: {
        diffDays: {
          $divide: [
            { $subtract: ["$maxCompletedAt", "$planted_date"] },
            1000 * 60 * 60 * 24,
          ],
        },
      },
    },
    { $group: { _id: null, avgGrowDays: { $avg: "$diffDays" } } },
  ]);

  const avgGrowDays = avgGrowAgg[0]?.avgGrowDays ?? null;

  const byType = {};
  byTypeAgg.forEach((r) => (byType[r._id || "Unknown"] = r.count));

  const byGroup = {};
  byGroupAgg.forEach((r) => (byGroup[r._id || "unknown"] = r.count));

  const result = {
    byType,
    byGroup,
    mostPopularType,
    progressAvg: Math.round(avgProgress),
    progressDistribution,
    avgGrowDays: avgGrowDays ? Math.round(avgGrowDays) : null,
  };

  return ok(res, result, null, "Notebook statistics fetched successfully");
});
