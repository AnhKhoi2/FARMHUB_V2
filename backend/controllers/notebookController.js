import Notebook from "../models/Notebook.js";
import mongoose from "mongoose";
import Guide from "../models/Guide.js";
import PlantTemplate from "../models/PlantTemplate.js";
import { ok, created, noContent } from "../utils/ApiResponse.js";
import { asyncHandler } from "../utils/asyncHandler.js";
import { AppError } from "../utils/AppError.js";
import {
  sendDailyReminderNotification,
  sendNotebookCompletedNotification,
} from "./notificationController.js";
import {
  getDaysDifferenceVN,
  toVietnamMidnight,
  getVietnamToday,
  formatVietnamDate,
  formatVietnamDatetime,
  parseVietnamDate,
} from "../utils/timezone.js";

// ==========================================
// HELPER FUNCTIONS (from services)
// ==========================================

/**
 * TÃ­nh sá»‘ ngÃ y tá»« startDate Ä‘áº¿n endDate (theo giá» Viá»‡t Nam UTC+7)
 * Sá»­ dá»¥ng helper tá»« timezone.js
 */
const getDaysDifference = getDaysDifferenceVN;

/**
 * TÃ­nh stage end date dá»±a trÃªn planted_date vÃ  stage.day_end (theo giá» Viá»‡t Nam UTC+7)
 */
const getStageEndDate = (plantedDate, stageEndDay) => {
  const endDate = new Date(plantedDate);
  endDate.setDate(endDate.getDate() + stageEndDay - 1);
  return toVietnamMidnight(endDate);
};

/**
 * TÃ­nh ngÃ y báº¯t Ä‘áº§u cá»§a stage dá»±a trÃªn planted_date vÃ  stage.day_start
 */
const getStageStartDate = (plantedDate, stageStartDay) => {
  const startDate = new Date(plantedDate);
  startDate.setDate(startDate.getDate() + stageStartDay - 1);
  return toVietnamMidnight(startDate);
};

/**
 * Kiá»ƒm tra xem notification Ä‘Ã£ Ä‘Æ°á»£c gá»­i chÆ°a
 */
const hasNotificationBeenSent = (notificationsSent, type, missedDay) => {
  return notificationsSent?.some((n) => n.type === type && n.day === missedDay);
};

/**
 * Láº¥y template phÃ¹ há»£p vá»›i notebook (dá»±a trÃªn guide's plant_group)
 */
const getTemplateForNotebook = async (notebookId) => {
  const notebook = await Notebook.findById(notebookId).populate("guide_id");

  if (!notebook) {
    throw new AppError("KhÃ´ng tÃ¬m tháº¥y nháº­t kÃ½", 404);
  }

  if (notebook.template_id) {
    const template = await PlantTemplate.findById(notebook.template_id);
    return template;
  }

  if (notebook.guide_id && notebook.guide_id.plant_group) {
    const template = await PlantTemplate.findOne({
      plant_group: notebook.guide_id.plant_group,
      status: "active",
    }).sort({ usage_count: -1 });

    return template;
  }

  return null;
};

/**
 * GÃ¡n template cho notebook
 */
const assignTemplateToNotebook = async (notebookId, templateId) => {
  const notebook = await Notebook.findById(notebookId);
  const template = await PlantTemplate.findById(templateId);

  if (!notebook) {
    throw new AppError("KhÃ´ng tÃ¬m tháº¥y nháº­t kÃ½", 404);
  }

  if (!template) {
    throw new AppError("KhÃ´ng tÃ¬m tháº¥y template", 404);
  }

  notebook.template_id = templateId;

  notebook.stages_tracking = template.stages.map((stage, index) => ({
    stage_number: stage.stage_number,
    stage_name: stage.name,
    started_at:
      index === 0
        ? getStageStartDate(notebook.planted_date, stage.day_start)
        : null,
    is_current: index === 0,
  }));

  notebook.current_stage = 1;

  // âœ… Khá»Ÿi táº¡o progress = 0 khi gÃ¡n template láº§n Ä‘áº§u
  // Progress sáº½ chá»‰ tÄƒng lÃªn khi hoÃ n thÃ nh observations á»Ÿ cuá»‘i má»—i stage
  notebook.progress = 0;

  await notebook.save();

  template.usage_count += 1;
  await template.save();

  await generateDailyChecklist(notebookId);

  return notebook;
};

/**
 * Táº¡o daily checklist tá»« template's autogenerated_tasks
 */
export const generateDailyChecklist = async (notebookId) => {
  const notebook = await Notebook.findById(notebookId).populate("template_id");

  if (!notebook || !notebook.template_id) {
    return null;
  }

  // âœ… Kiá»ƒm tra notebook Ä‘Ã£ hoÃ n thÃ nh 100% -> khÃ´ng táº¡o task má»›i
  const isNotebookCompleted =
    notebook.progress === 100 &&
    Array.isArray(notebook.stages_tracking) &&
    notebook.stages_tracking.length > 0 &&
    notebook.stages_tracking.every((s) => s.status === "completed");

  if (isNotebookCompleted) {
    console.log(
      `âœ… Notebook ${notebookId} Ä‘Ã£ hoÃ n thÃ nh 100% - khÃ´ng táº¡o task má»›i`
    );
    // Return empty checklist for completed notebooks
    return notebook.daily_checklist || [];
  }

  const template = notebook.template_id;
  const today = getVietnamToday();

  // ğŸ”„ KIá»‚M TRA VÃ€ Tá»° Äá»˜NG CHUYá»‚N STAGE Náº¾U CÃ“ PENDING TRANSITION
  const currentStageTracking = notebook.stages_tracking?.find(
    (s) => s.stage_number === notebook.current_stage
  );

  if (currentStageTracking?.pending_transition) {
    const transitionDate = currentStageTracking.transition_date
      ? toVietnamMidnight(new Date(currentStageTracking.transition_date))
      : null;

    // Náº¿u Ä‘Ã£ qua ngÃ y hoÃ n thÃ nh observations â†’ chuyá»ƒn stage
    if (transitionDate && today.getTime() > transitionDate.getTime()) {
      console.log(
        `ğŸ”„ Auto-transitioning from stage ${notebook.current_stage} (observations completed yesterday)`
      );

      const nextStageNumber = notebook.current_stage + 1;
      if (nextStageNumber <= template.stages.length) {
        // Táº¯t current flag cá»§a stage hiá»‡n táº¡i
        currentStageTracking.is_current = false;
        currentStageTracking.pending_transition = false;

        // Báº­t current flag cho stage tiáº¿p theo
        const nextStageTracking = notebook.stages_tracking.find(
          (s) => s.stage_number === nextStageNumber
        );

        if (nextStageTracking) {
          nextStageTracking.is_current = true;
          const nextTemplateStage = template.stages.find(
            (s) => s.stage_number === nextStageNumber
          );
          if (nextTemplateStage) {
            nextStageTracking.started_at = getStageStartDate(
              notebook.planted_date,
              nextTemplateStage.day_start
            );
          } else {
            nextStageTracking.started_at = today;
          }
          nextStageTracking.status = "active";
        }

        // Cáº­p nháº­t current_stage
        notebook.current_stage = nextStageNumber;
        await notebook.save();

        console.log(`âœ… Stage switched to ${nextStageNumber}`);
      }
    }
  }

  // Reload láº¡i sau khi cÃ³ thá»ƒ Ä‘Ã£ chuyá»ƒn stage
  const updatedStageTracking = notebook.stages_tracking?.find(
    (s) => s.stage_number === notebook.current_stage
  );

  const currentStage = template.stages.find(
    (s) => s.stage_number === notebook.current_stage
  );

  if (!currentStage) {
    console.log(
      `âš ï¸ generateDailyChecklist: template stage not found for notebook ${notebookId} stage ${notebook.current_stage}`
    );
    return null;
  }

  // daysInStage: if tracking started_at exists use it, otherwise fallback to template-based calculation
  let daysInStage;
  if (updatedStageTracking && updatedStageTracking.started_at) {
    daysInStage = getDaysDifference(updatedStageTracking.started_at, today) + 1;
  } else {
    daysInStage = Math.floor(notebook.current_day) - currentStage.day_start + 1;
  }

  // Náº¿u Ä‘Ã£ cÃ³ checklist Ä‘Æ°á»£c sinh vÃ o ngÃ y trÆ°á»›c Ä‘Ã³ -> sang ngÃ y má»›i, xá»­ lÃ½
  // cÃ¡c task chÆ°a hoÃ n thÃ nh cá»§a ngÃ y trÆ°á»›c thÃ nh overdue, ghi vÃ o stages_tracking
  const lastGenerated = notebook.last_checklist_generated
    ? toVietnamMidnight(new Date(notebook.last_checklist_generated))
    : null;

  if (lastGenerated && lastGenerated.getTime() < today.getTime()) {
    if (updatedStageTracking) {
      const incompleteTasks = (notebook.daily_checklist || []).filter(
        (t) => !t.is_completed && t.status === "pending"
      );

      if (incompleteTasks.length > 0) {
        // Ensure overdue_tasks array exists
        if (!updatedStageTracking.overdue_tasks)
          updatedStageTracking.overdue_tasks = [];

        incompleteTasks.forEach((task) => {
          // mark the checklist item as overdue
          task.status = "overdue";
          task.overdue_at = today;

          // persist an overdue task entry for history and UI
          updatedStageTracking.overdue_tasks.push({
            task_name: task.task_name,
            description: task.description || "",
            original_date: lastGenerated,
            status: "overdue",
            overdue_at: today,
          });
        });

        updatedStageTracking.overdue_summary = {
          date: lastGenerated,
          overdue_count: incompleteTasks.length,
          ready_to_notify: true,
        };

        // Try to send immediate daily reminder notification
        try {
          await sendDailyReminderNotification({
            userId: notebook.user_id,
            notebookId: notebook._id,
            notebookName: notebook.notebook_name,
            incompleteTasks: incompleteTasks.length,
          });
        } catch (e) {
          console.warn("Failed to send daily reminder notification:", e);
        }
      }
    }
  }

  let newChecklist = [];
  const allTasks =
    currentStage.autogenerated_tasks || currentStage.daily_tasks || [];
  if (daysInStage === 1) {
    // NgÃ y Ä‘áº§u stage: hiá»ƒn thá»‹ toÃ n bá»™ task
    newChecklist = allTasks.map((task) => {
      let completedEntry = null;
      if (updatedStageTracking?.completed_tasks) {
        completedEntry = updatedStageTracking.completed_tasks.find((t) => {
          if (t.task_name !== task.task_name) return false;
          if (!t.completed_at) return false;
          try {
            const completedAt = toVietnamMidnight(new Date(t.completed_at));
            return completedAt.getTime() === today.getTime();
          } catch (e) {
            return false;
          }
        });
      }
      const isCompleted = !!completedEntry;
      return {
        task_name: task.task_name,
        description: task.description,
        priority: task.priority,
        frequency: task.frequency,
        is_completed: isCompleted,
        status: isCompleted ? "completed" : "pending",
        completed_at: isCompleted ? completedEntry.completed_at : null,
        created_at: today,
      };
    });
  } else {
    // Nhá»¯ng ngÃ y tiáº¿p theo: chá»‰ hiá»ƒn thá»‹ task theo táº§n suáº¥t
    newChecklist = allTasks
      .filter((task) => {
        // Always show daily tasks
        if (task.frequency === "daily") return true;

        // Interval-based tasks: prefer last completion date if available
        const intervalMap = {
          every_2_days: 2,
          every_3_days: 3,
          weekly: 7,
        };

        const interval = intervalMap[task.frequency];
        if (!interval) return false;

        // Find last completed entry for this task in current stage
        const lastCompleted = updatedStageTracking?.completed_tasks
          ? updatedStageTracking.completed_tasks
              .filter((t) => t.task_name === task.task_name)
              .reduce((latest, t) => {
                if (!latest) return t;
                return new Date(t.completed_at) > new Date(latest.completed_at)
                  ? t
                  : latest;
              }, null)
          : null;

        if (lastCompleted && lastCompleted.completed_at) {
          const daysSinceLast = getDaysDifference(
            lastCompleted.completed_at,
            today
          );
          // Show when days since last completion is >= interval and matches the interval cadence
          return daysSinceLast >= interval && daysSinceLast % interval === 0;
        }

        // Fallback to original stage-based cadence if never completed in this stage
        // We treat the first day of the stage as day 1 (anchor). For an
        // "every_N_days" cadence we want to show on day 1, then day 1+N,
        // 1+2N, ... so use (daysInStage - 1) % interval === 0.
        return (daysInStage - 1) % interval === 0;
      })
      .map((task) => {
        let completedEntry = null;
        if (updatedStageTracking?.completed_tasks) {
          completedEntry = updatedStageTracking.completed_tasks.find((t) => {
            if (t.task_name !== task.task_name) return false;
            if (!t.completed_at) return false;
            try {
              const completedAt = toVietnamMidnight(new Date(t.completed_at));
              return completedAt.getTime() === today.getTime();
            } catch (e) {
              return false;
            }
          });
        }
        const isCompleted = !!completedEntry;
        return {
          task_name: task.task_name,
          description: task.description,
          priority: task.priority,
          frequency: task.frequency,
          is_completed: isCompleted,
          status: isCompleted ? "completed" : "pending",
          completed_at: isCompleted ? completedEntry.completed_at : null,
          created_at: today,
        };
      });
  }

  notebook.daily_checklist = newChecklist;
  notebook.last_checklist_generated = today;
  // Store VN datetime string for direct display in DB to avoid UTC confusion
  try {
    notebook.last_checklist_generated_vn = formatVietnamDatetime(today);
  } catch (e) {
    // Non-fatal: if formatting fails, leave VN string undefined
    console.warn("Failed to format last_checklist_generated_vn:", e);
  }
  // Ensure today's daily_log reflects the newly generated checklist so that
  // `stages_tracking.daily_logs` stays consistent with `daily_checklist`.
  try {
    if (updatedStageTracking) {
      if (!updatedStageTracking.daily_logs)
        updatedStageTracking.daily_logs = [];

      const todayKey = today.toISOString().split("T")[0];
      let todayLog = updatedStageTracking.daily_logs.find(
        (log) =>
          toVietnamMidnight(new Date(log.date)).toISOString().split("T")[0] ===
          todayKey
      );

      const todayTasks = newChecklist || [];
      const completedTodayTasks = todayTasks.filter(
        (t) => t.is_completed
      ).length;
      const totalTodayTasks = todayTasks.length || 0;

      if (!todayLog) {
        todayLog = { date: today, daily_progress: 0 };
        updatedStageTracking.daily_logs.push(todayLog);
      }

      if (totalTodayTasks > 0) {
        todayLog.daily_progress = Math.round(
          (completedTodayTasks / totalTodayTasks) * 100
        );
      } else {
        // If no tasks today, keep existing progress or set to 0 conservatively
        todayLog.daily_progress = todayLog.daily_progress || 0;
      }
    }
  } catch (e) {
    console.warn(
      "Failed to synchronize daily_log with generated checklist:",
      e
    );
  }
  await notebook.save();

  return newChecklist;
};

/**
 * Cáº­p nháº­t stage hiá»‡n táº¡i
 */
const updateCurrentStage = async (notebookId, newStageNumber) => {
  const notebook = await Notebook.findById(notebookId).populate("template_id");

  if (!notebook || !notebook.template_id) {
    throw new AppError("KhÃ´ng tÃ¬m tháº¥y nháº­t kÃ½ hoáº·c template", 404);
  }

  const template = notebook.template_id;

  if (newStageNumber > template.stages.length) {
    throw new AppError("Sá»‘ stage khÃ´ng há»£p lá»‡", 400);
  }

  const oldStageIndex = notebook.stages_tracking.findIndex(
    (s) => s.stage_number === notebook.current_stage
  );
  if (oldStageIndex !== -1) {
    notebook.stages_tracking[oldStageIndex].is_current = false;
    // Set completed_at to the template-based stage end date (normalized to VN day-start)
    const oldStageNumber = notebook.current_stage;
    const oldTemplateStage = template.stages.find(
      (s) => s.stage_number === oldStageNumber
    );
    if (oldTemplateStage) {
      notebook.stages_tracking[oldStageIndex].completed_at = getStageEndDate(
        notebook.planted_date,
        oldTemplateStage.day_end
      );
    } else {
      notebook.stages_tracking[oldStageIndex].completed_at = new Date();
    }
  }

  const newStageIndex = notebook.stages_tracking.findIndex(
    (s) => s.stage_number === newStageNumber
  );
  if (newStageIndex !== -1) {
    notebook.stages_tracking[newStageIndex].is_current = true;
    // When activating a new stage, set its started_at to the template-planned start date
    // (planted_date + stage.day_start - 1) normalized to VN day-start. This keeps
    // persisted started_at consistent with the template schedule for future notebooks.
    const newTemplateStage = template.stages.find(
      (s) => s.stage_number === newStageNumber
    );
    if (newTemplateStage) {
      notebook.stages_tracking[newStageIndex].started_at = getStageStartDate(
        notebook.planted_date,
        newTemplateStage.day_start
      );
    } else {
      notebook.stages_tracking[newStageIndex].started_at = getVietnamToday();
    }
  }

  notebook.current_stage = newStageNumber;

  // âš ï¸ KHï¿½ï¿½NG cáº­p nháº­t progress á»Ÿ Ä‘Ã¢y - chá»‰ cáº­p nháº­t khi hoÃ n thÃ nh observations
  // Náº¿u admin/user chuyá»ƒn stage thá»§ cÃ´ng, progress sáº½ Ä‘Æ°á»£c cáº­p nháº­t khi há» hoÃ n thÃ nh observations
  // await notebook.updateProgress(template.stages);

  await notebook.save();

  // Generate today's checklist immediately for the newly-activated stage
  await generateDailyChecklist(notebookId);

  return notebook;
};

/**
 * Kiá»ƒm tra vÃ  xá»­ lÃ½ tráº¡ng thÃ¡i stage cá»§a notebook (stage monitoring)
 */
export const checkNotebookStageStatus = async (notebook) => {
  try {
    if (!notebook.populated("template_id")) {
      await notebook.populate("template_id");
    }

    if (!notebook.template_id || !notebook.template_id.stages) {
      console.log(`âš ï¸ Notebook ${notebook._id} khÃ´ng cÃ³ template`);
      return;
    }

    const template = notebook.template_id;
    const today = getVietnamToday();

    const currentStageTracking = notebook.stages_tracking.find(
      (s) => s.stage_number === notebook.current_stage
    );

    if (!currentStageTracking) {
      console.log(
        `âš ï¸ KhÃ´ng tÃ¬m tháº¥y stage_tracking cho stage ${notebook.current_stage}`
      );
      return;
    }

    if (
      currentStageTracking.status === "completed" ||
      currentStageTracking.status === "skipped"
    ) {
      console.log(
        `âœ… Stage ${notebook.current_stage} Ä‘Ã£ ${currentStageTracking.status}, bá» qua`
      );
      return;
    }

    const templateStage = template.stages.find(
      (s) => s.stage_number === notebook.current_stage
    );

    if (!templateStage) {
      console.log(
        `âš ï¸ KhÃ´ng tÃ¬m tháº¥y template stage cho stage ${notebook.current_stage}`
      );
      return;
    }

    const stageEndDate = getStageEndDate(
      notebook.planted_date,
      templateStage.day_end
    );
    const daysAfterEnd = getDaysDifference(stageEndDate, today);

    console.log(
      `ğŸ“… Notebook: ${notebook.notebook_name} | Stage: ${
        templateStage.name
      } | End Date: ${
        stageEndDate.toISOString().split("T")[0]
      } | Days After End: ${daysAfterEnd}`
    );

    // NOTE: Missed-day processing has been disabled globally for notebooks.
    // The application should no longer apply missed_days calculations,
    // send overdue/exceeded notifications, or auto-skip stages based on
    // how many days have passed since the planned stage end.
    console.log(
      "â„¹ï¸ Missed-day processing disabled for notebooks â€” skipping related actions."
    );
    return;

    // Missed-day / auto-skip logic has been removed per request.
    // Previously the code here would compute missedDays, send warnings,
    // and optionally auto-complete observations and advance stages.
    // That behavior is intentionally deleted to avoid any auto-skip based on
    // missed days. All remaining stage transitions must be performed
    // manually via observations or explicit admin actions.
  } catch (error) {
    console.error(`âŒ Lá»—i khi check notebook ${notebook._id}:`, error);
  }
};

/**
 * ÄÃ¡nh dáº¥u hoÃ n thÃ nh task trong checklist
 */
const completeChecklistTask = async (notebookId, taskName) => {
  // Ensure today's checklist exists (generate if needed) so progress calculation is accurate
  await generateDailyChecklist(notebookId);
  const notebook = await Notebook.findById(notebookId).populate("template_id");

  if (!notebook) {
    throw new AppError("KhÃ´ng tÃ¬m tháº¥y nháº­t kÃ½", 404);
  }

  console.log(
    `ğŸ”” completeChecklistTask called for notebook=${notebookId} taskName='${taskName}'`
  );
  const task = notebook.daily_checklist.find((t) => t.task_name === taskName);
  if (!task) {
    // Try fuzzy match by trimming/normalizing whitespace for better diagnostics
    const alt = notebook.daily_checklist.find(
      (t) =>
        (t.task_name || "").trim().toLowerCase() ===
        (taskName || "").trim().toLowerCase()
    );
    if (alt) {
      console.warn(
        `âš ï¸ Task name mismatch: exact match not found but fuzzy match succeeded. Using '${alt.task_name}'`
      );
    }
  }

  if (!task) {
    throw new AppError("KhÃ´ng tÃ¬m tháº¥y cÃ´ng viá»‡c", 404);
  }

  const prev = {
    is_completed: task.is_completed,
    completed_at: task.completed_at,
  };
  task.is_completed = !task.is_completed;
  task.completed_at = task.is_completed ? new Date() : null;
  task.status = task.is_completed ? "completed" : "pending"; // âœ… Update status
  console.log(
    `â„¹ï¸ Task '${task.task_name}' toggled: ${prev.is_completed} -> ${task.is_completed}; completed_at=${task.completed_at}`
  );

  const currentStageTracking = notebook.stages_tracking.find(
    (s) => s.stage_number === notebook.current_stage
  );

  if (currentStageTracking) {
    if (task.is_completed) {
      const alreadyCompleted = currentStageTracking.completed_tasks?.some(
        (t) => t.task_name === taskName
      );

      if (!alreadyCompleted) {
        if (!currentStageTracking.completed_tasks) {
          currentStageTracking.completed_tasks = [];
        }
        currentStageTracking.completed_tasks.push({
          task_name: taskName,
          completed_at: new Date(),
        });
      } else {
        // If an entry exists from previous days, update its completed_at to today
        const existing = currentStageTracking.completed_tasks.find(
          (t) => t.task_name === taskName
        );
        if (existing) {
          existing.completed_at = new Date();
          console.log(
            `â„¹ï¸ Updated existing completed_tasks entry for '${taskName}' to today.`
          );
        }
      }
    } else {
      if (currentStageTracking.completed_tasks) {
        currentStageTracking.completed_tasks =
          currentStageTracking.completed_tasks.filter(
            (t) => t.task_name !== taskName
          );
      }
    }
  }

  // âš ï¸ KHÃ”NG cáº­p nháº­t progress á»Ÿ Ä‘Ã¢y - chá»‰ cáº­p nháº­t khi hoÃ n thÃ nh observations
  // Progress chá»‰ Ä‘Æ°á»£c cáº­p nháº­t khi hoÃ n thÃ nh táº¥t cáº£ observations á»Ÿ cuá»‘i giai Ä‘oáº¡n
  if (notebook.template_id && notebook.template_id.stages) {
    console.log(
      `ğŸ“‹ Completed tasks in current stage: ${
        currentStageTracking?.completed_tasks?.length || 0
      }`
    );
  }

  if (currentStageTracking) {
    // Update today's daily_log based on the (possibly newly generated) daily_checklist
    const todayDate = getVietnamToday();
    const today = todayDate.toISOString().split("T")[0];

    console.log(
      `ğŸ” Checking daily_logs for stage ${notebook.current_stage} on ${today}`
    );

    if (!currentStageTracking.daily_logs) currentStageTracking.daily_logs = [];

    let dailyLog = currentStageTracking.daily_logs.find(
      (log) => log.date?.toISOString().split("T")[0] === today
    );

    if (!dailyLog) {
      dailyLog = { date: todayDate, daily_progress: 0 };
      currentStageTracking.daily_logs.push(dailyLog);
      console.log(`â• Created new daily_log for ${today}`);
    } else {
      console.log(
        `âœ… Found existing daily_log for ${today}: ${dailyLog.daily_progress}%`
      );
    }

    const todayTasks = notebook.daily_checklist || [];
    const completedTodayTasks = todayTasks.filter((t) => t.is_completed).length;
    const totalTodayTasks = todayTasks.length;

    if (totalTodayTasks > 0) {
      dailyLog.daily_progress = Math.round(
        (completedTodayTasks / totalTodayTasks) * 100
      );
      console.log(
        `ğŸ“… Daily progress for ${today}: ${dailyLog.daily_progress}% (${completedTodayTasks}/${totalTodayTasks})`
      );
    }
  } else {
    console.warn(
      `âš ï¸ No currentStageTracking found for stage ${notebook.current_stage}`
    );
  }

  if (currentStageTracking && notebook.template_id) {
    const stageCompletion = await notebook.getCurrentStageCompletion();
    console.log(`ğŸ¯ Current stage completion: ${stageCompletion}%`);

    // âš ï¸ KhÃ´ng tá»± Ä‘á»™ng mark stage completed chá»‰ dá»±a vÃ o tasks
    // Stage chá»‰ Ä‘Æ°á»£c mark completed khi hoÃ n thÃ nh observations á»Ÿ updateStageObservation
    console.log(
      `â„¹ï¸ Stage completion: ${stageCompletion}% (waiting for observations to complete stage)`
    );
  }

  await notebook.save();

  return notebook;
};

/**
 * Láº¥y táº¥t cáº£ observations cá»§a stage hiá»‡n táº¡i
 * CHá»ˆ tráº£ vá» observations náº¿u Ä‘ang á»Ÿ ngÃ y cuá»‘i cá»§a giai Ä‘oáº¡n
 */
const getCurrentStageObservations = async (notebookId) => {
  const notebook = await Notebook.findById(notebookId).populate("template_id");

  if (!notebook || !notebook.template_id) {
    return [];
  }

  const template = notebook.template_id;
  const currentStage = template.stages.find(
    (s) => s.stage_number === notebook.current_stage
  );

  if (!currentStage) {
    return [];
  }

  // Kiá»ƒm tra xem cÃ³ pháº£i ngÃ y cuá»‘i cá»§a giai Ä‘oáº¡n khÃ´ng hoáº·c Ä‘Ã£ qua ngÃ y cuá»‘i
  const currentDay = notebook.current_day || 1;
  const isLastDayOfStage = currentDay === currentStage.day_end;
  const isPastLastDay = currentDay > currentStage.day_end;

  // Náº¿u stage Ä‘Ã£ completed thÃ¬ khÃ´ng tráº£ vá» observation required ná»¯a
  const stageTracking = notebook.stages_tracking.find(
    (s) => s.stage_number === notebook.current_stage
  );
  if (stageTracking && stageTracking.status === "completed") {
    // Tráº£ vá» danh sÃ¡ch observation Ä‘Ã£ ghi nháº­n (cÃ³ value=true)
    return (
      stageTracking.observations?.map((obs) => ({
        key: obs.key,
        value: obs.value,
        observed_at: obs.observed_at,
        completed: true,
      })) || []
    );
  }

  // âœ… Kiá»ƒm tra xem Ä‘Ã£ cÃ³ observations chÆ°a hoÃ n thÃ nh
  const hasIncompleteObservations =
    stageTracking?.observations &&
    stageTracking.observations.length > 0 &&
    (currentStage?.observation_required || []).some((obsReq) => {
      const found = stageTracking.observations.find(
        (o) => o.key === obsReq.key
      );
      return !found || found.value !== true;
    });

  // âœ… Kiá»ƒm tra xem Ä‘Ã£ táº¡o observations nhÆ°ng chÆ°a check (tá»« ngÃ y cuá»‘i)
  const hasObservationsStarted =
    stageTracking?.observations && stageTracking.observations.length > 0;

  // CHá»ˆ tráº£ vá» observations náº¿u:
  // 1. Äang á»Ÿ ngÃ y cuá»‘i cá»§a giai Ä‘oáº¡n HOáº¶C
  // 2. ÄÃ£ qua ngÃ y cuá»‘i NHÆ¯NG Ä‘Ã£ cÃ³ observations Ä‘Æ°á»£c táº¡o vÃ  chÆ°a hoÃ n thÃ nh (giá»¯ observations cho Ä‘áº¿n khi user check xong)
  // 3. ÄÃ£ cÃ³ observations chÆ°a hoÃ n thÃ nh (tá»“n táº¡i cho Ä‘áº¿n khi user check háº¿t)
  if (!isLastDayOfStage && !isPastLastDay && !hasIncompleteObservations) {
    return [];
  }

  // Náº¿u Ä‘Ã£ qua ngÃ y cuá»‘i nhÆ°ng chÆ°a tá»«ng cÃ³ observations thÃ¬ khÃ´ng hiá»ƒn thá»‹ ná»¯a
  if (isPastLastDay && !hasObservationsStarted) {
    return [];
  }

  // Tráº£ vá» danh sÃ¡ch observation required, kÃ¨m tráº¡ng thÃ¡i Ä‘Ã£ hoÃ n thÃ nh náº¿u cÃ³
  return (currentStage?.observation_required || []).map((obsReq) => {
    const found = stageTracking?.observations?.find(
      (o) => o.key === obsReq.key
    );
    return {
      ...obsReq,
      value: found?.value ?? false,
      observed_at: found?.observed_at ?? null,
      completed: !!found?.value,
    };
  });
};

/**
 * Cáº­p nháº­t observation cho stage hiá»‡n táº¡i
 */
export const updateStageObservation = async (
  notebookId,
  observationKey,
  value
) => {
  // Ensure today's checklist is up-to-date before validating observations.
  // This keeps `daily_checklist` and `stages_tracking.daily_logs` consistent
  // with the current date and any recently completed tasks.
  await generateDailyChecklist(notebookId);

  const notebook = await Notebook.findById(notebookId).populate("template_id");

  if (!notebook) {
    throw new AppError("KhÃ´ng tÃ¬m tháº¥y nháº­t kÃ½", 404);
  }

  const stageTracking = notebook.stages_tracking.find(
    (s) => s.stage_number === notebook.current_stage
  );

  if (!stageTracking) {
    throw new AppError("KhÃ´ng tÃ¬m tháº¥y stage tracking", 404);
  }

  // âœ… KIá»‚M TRA: Táº¥t cáº£ tasks hÃ´m nay vÃ  overdue tasks pháº£i hoÃ n thÃ nh trÆ°á»›c khi check observations
  const todayTasks = notebook.daily_checklist || [];
  const incompleteTodayTasks = todayTasks.filter((t) => !t.is_completed);

  const overdueTasks = stageTracking.overdue_tasks || [];
  const pendingOverdue = overdueTasks.filter(
    (t) => t.status === "overdue" || t.status === "pending"
  );

  if (incompleteTodayTasks.length > 0 || pendingOverdue.length > 0) {
    let parts = [];
    if (pendingOverdue.length > 0) {
      parts.push(`${pendingOverdue.length} cÃ´ng viá»‡c trá»… cáº§n hoÃ n thÃ nh`);
    }
    if (incompleteTodayTasks.length > 0) {
      parts.push(
        `${incompleteTodayTasks.length} cÃ´ng viá»‡c hÃ´m nay chÆ°a hoÃ n thÃ nh`
      );
    }

    const message = `Vui lÃ²ng hoÃ n thÃ nh: ${parts.join(
      " vÃ  "
    )} trÆ°á»›c khi kiá»ƒm tra Ä‘iá»u kiá»‡n quan sÃ¡t.`;
    throw new AppError(message, 400, "TASKS_NOT_COMPLETED");
  }

  const existingObs = stageTracking.observations.find(
    (o) => o.key === observationKey
  );

  if (existingObs) {
    existingObs.value = value;
    existingObs.observed_at = new Date();
  } else {
    stageTracking.observations.push({
      key: observationKey,
      value: value,
      observed_at: new Date(),
    });
  }

  await notebook.save();

  // âœ… Kiá»ƒm tra xem táº¥t cáº£ observations Ä‘Ã£ hoÃ n thÃ nh chÆ°a
  if (notebook.template_id && notebook.template_id.stages) {
    const currentTemplateStage = notebook.template_id.stages.find(
      (s) => s.stage_number === notebook.current_stage
    );

    if (currentTemplateStage && currentTemplateStage.observation_required) {
      const requiredObservations = currentTemplateStage.observation_required;
      const completedObservations = stageTracking.observations.filter(
        (obs) => obs.value === true
      );

      console.log(
        `ğŸ“Š Observations: ${completedObservations.length}/${requiredObservations.length} completed`
      );

      // Náº¿u táº¥t cáº£ observations báº¯t buá»™c Ä‘Ã£ hoÃ n thÃ nh (value = true)
      if (completedObservations.length >= requiredObservations.length) {
        console.log(
          `âœ… All observations completed for stage ${notebook.current_stage}`
        );

        // ÄÃ¡nh dáº¥u stage hiá»‡n táº¡i hoÃ n thÃ nh (sá»­ dá»¥ng template-based end date)
        const currentTemplateStage = notebook.template_id.stages.find(
          (s) => s.stage_number === notebook.current_stage
        );
        stageTracking.completed_at = currentTemplateStage
          ? getStageEndDate(notebook.planted_date, currentTemplateStage.day_end)
          : new Date();
        stageTracking.status = "completed";

        // âœ… Cáº¬P NHáº¬T PROGRESS - Chá»‰ cáº­p nháº­t á»Ÿ Ä‘Ã¢y khi hoÃ n thÃ nh observations
        // ÄÃ¢y lÃ  NÆ I DUY NHáº¤T Ä‘Æ°á»£c phÃ©p cáº­p nháº­t progress cá»§a toÃ n bá»™ notebook
        await notebook.updateProgress(notebook.template_id.stages);
        console.log(`ğŸŒ± Plant progress updated: ${notebook.progress}%`);

        // ğŸ‰ KIá»‚M TRA HOÃ€N THÃ€NH NOTEBOOK 100%
        if (notebook.progress === 100) {
          const allStagesCompleted = notebook.stages_tracking.every(
            (s) => s.completed_at
          );

          if (allStagesCompleted) {
            console.log(
              `ğŸŠ Notebook ${notebook.notebook_name} hoÃ n thÃ nh 100%! Gá»­i thÃ´ng bÃ¡o...`
            );

            // Gá»­i thÃ´ng bÃ¡o hoÃ n thÃ nh notebook
            await sendNotebookCompletedNotification({
              userId: notebook.user_id,
              notebookId: notebook._id,
              notebookName: notebook.notebook_name,
              plantType: notebook.plant_type || "cÃ¢y",
              totalDays: notebook.current_day,
            });
          }
        }

        // ğŸ“… ÄÃNH Dáº¤U CHO CHUYá»‚N STAGE VÃ€O NGÃ€Y HÃ”M SAU
        // KhÃ´ng chuyá»ƒn stage ngay, chá»‰ Ä‘Ã¡nh dáº¥u pending_transition
        stageTracking.pending_transition = true;
        stageTracking.transition_date = getVietnamToday(); // NgÃ y hoÃ n thÃ nh observations

        console.log(
          `ğŸ•’ Stage ${notebook.current_stage} marked as pending transition. Will switch to next stage tomorrow.`
        );

        await notebook.save();
      } else {
        await notebook.save();
      }
    } else {
      await notebook.save();
    }
  }

  return notebook;
};

/**
 * TÃ­nh stage hiá»‡n táº¡i dá»±a trÃªn sá»‘ ngÃ y Ä‘Ã£ trá»“ng
 */
const calculateCurrentStage = async (notebookId) => {
  const notebook = await Notebook.findById(notebookId).populate("template_id");

  if (!notebook || !notebook.template_id) {
    return null;
  }

  const template = notebook.template_id;
  const daysPlanted = notebook.current_day;

  const stageInfo = template.getStageByDay(daysPlanted);

  if (stageInfo && stageInfo.stage_number !== notebook.current_stage) {
    await updateCurrentStage(notebookId, stageInfo.stage_number);
  }

  return stageInfo;
};

// ==========================================
// CONTROLLER EXPORTS
// ==========================================

// ğŸ“˜ Láº¥y táº¥t cáº£ notebook cá»§a user
export const getAllByUser = asyncHandler(async (req, res) => {
  const notebooks = await Notebook.find({
    user_id: req.user.id,
    status: { $ne: "deleted" },
  })
    .populate("guide_id", "title category difficulty estimatedTime")
    .populate("template_id", "template_name plant_group status stages")
    .sort({ createdAt: -1 });

  return ok(
    res,
    notebooks,
    {
      count: notebooks.length,
      timezone: "Asia/Ho_Chi_Minh (UTC+7)",
    },
    "Fetched all notebooks successfully"
  );
});

// ğŸ“— Láº¥y chi tiáº¿t notebook theo ID
export const getNotebookById = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const notebook = await Notebook.findOne({
    _id: id,
    user_id: req.user.id,
    status: { $ne: "deleted" },
  })
    .populate(
      "guide_id",
      "title category difficulty estimatedTime description steps"
    )
    .populate("template_id");

  if (!notebook) {
    return res
      .status(404)
      .json({ success: false, message: "Notebook not found" });
  }

  // ThÃªm stage_completion % vÃ o response (now async)
  const notebookData = notebook.toObject();
  notebookData.stage_completion = await notebook.getCurrentStageCompletion();

  return ok(
    res,
    notebookData,
    { timezone: "Asia/Ho_Chi_Minh (UTC+7)" },
    "Fetched notebook detail successfully"
  );
});

// ğŸ“ Táº¡o má»›i notebook
export const createNotebook = asyncHandler(async (req, res) => {
  const { notebook_name, guide_id, description, cover_image, planted_date } =
    req.body;

  let plant_type = req.body.plant_type;
  let plant_group = null;
  let autoFoundTemplate = null;

  // âœ… FLOW Tá»° Äá»˜NG: Guide â†’ plant_group â†’ Template
  if (guide_id) {
    const guide = await Guide.findById(guide_id);
    if (!guide) {
      return res
        .status(404)
        .json({ success: false, message: "Guide not found" });
    }

    // Láº¥y plant_name vÃ  plant_group tá»« Guide
    plant_type = guide.plant_name || guide.title;
    plant_group = guide.plant_group;

    console.log(`ğŸ“— Guide found: ${guide.plant_name} â†’ Group: ${plant_group}`);

    // Tá»± Ä‘á»™ng tÃ¬m template dá»±a trÃªn plant_group
    if (plant_group && plant_group !== "other") {
      autoFoundTemplate = await PlantTemplate.findOne({
        plant_group: plant_group,
        status: "active",
      }).sort({ usage_count: -1 }); // Láº¥y template Ä‘Æ°á»£c dÃ¹ng nhiá»u nháº¥t

      if (autoFoundTemplate) {
        console.log(
          `âœ… Auto-found template: ${autoFoundTemplate.template_name}`
        );
      } else {
        console.log(`âš ï¸ No active template found for group: ${plant_group}`);
      }
    }
  }

  // If no guide_id provided, allow frontend to pass plant_group (slug) to auto-find template
  if (!guide_id && req.body.plant_group) {
    plant_group = req.body.plant_group;
    if (plant_group && plant_group !== "other") {
      autoFoundTemplate = await PlantTemplate.findOne({
        plant_group: plant_group,
        status: "active",
      }).sort({ usage_count: -1 });

      if (autoFoundTemplate) {
        console.log(
          `âœ… Auto-found template by plant_group: ${autoFoundTemplate.template_name}`
        );
      } else {
        console.log(`âš ï¸ No active template found for group: ${plant_group}`);
      }
    }
  }

  if (!plant_type) {
    return res.status(400).json({
      success: false,
      message:
        "plant_type is required. Provide either guide_id or plant_type directly.",
    });
  }

  // Táº¡o notebook vá»›i plant_group
  // Parse planted_date if provided; otherwise use precise UTC creation time
  // We store planted_date as a UTC instant (new Date()). For date-only strings
  // parseVietnamDate will interpret them as UTC-day-start; ISO datetime strings
  // will be parsed as provided.
  const normalizedPlantedDate = planted_date
    ? parseVietnamDate(planted_date)
    : new Date();

  const newNotebook = await Notebook.create({
    user_id: req.user.id,
    notebook_name,
    guide_id: guide_id || undefined,
    plant_type,
    plant_group: plant_group || "other",
    description,
    cover_image,
    planted_date: normalizedPlantedDate,
    planted_date_vn: formatVietnamDatetime(normalizedPlantedDate),
  });

  // âœ… Tá»° Äá»˜NG GÃN TEMPLATE náº¿u tÃ¬m Ä‘Æ°á»£c
  if (autoFoundTemplate) {
    try {
      const notebookWithTemplate = await assignTemplateToNotebook(
        newNotebook._id,
        autoFoundTemplate._id
      );

      console.log(
        `ğŸ‰ Template assigned successfully to notebook ${newNotebook._id}`
      );

      return created(
        res,
        notebookWithTemplate,
        `Notebook created with template: ${autoFoundTemplate.template_name}`
      );
    } catch (error) {
      console.error("âŒ Error assigning template:", error);
      // Váº«n tráº£ vá» notebook Ä‘Ã£ táº¡o, chá»‰ khÃ´ng cÃ³ template
      return created(
        res,
        newNotebook,
        "Notebook created but template assignment failed"
      );
    }
  }

  // KhÃ´ng tÃ¬m Ä‘Æ°á»£c template â†’ tráº£ vá» notebook thÆ°á»ng
  return created(
    res,
    newNotebook,
    "Notebook created successfully (no template found)"
  );
});

// ğŸ”„ Cáº­p nháº­t notebook
export const updateNotebook = asyncHandler(async (req, res) => {
  const { id } = req.params;
  // Normalize planted_date (if provided) to Vietnam day-start to avoid timezone shift
  if (req.body && req.body.planted_date !== undefined) {
    try {
      req.body.planted_date = req.body.planted_date
        ? parseVietnamDate(req.body.planted_date)
        : undefined;
      // Also persist VN datetime string for display/storage
      req.body.planted_date_vn =
        req.body.planted_date !== undefined
          ? req.body.planted_date
            ? formatVietnamDatetime(req.body.planted_date)
            : undefined
          : req.body.planted_date_vn;
    } catch (e) {
      return res.status(400).json({
        success: false,
        message: "Invalid planted_date format",
      });
    }
  }

  const notebook = await Notebook.findOneAndUpdate(
    { _id: id, user_id: req.user.id },
    req.body,
    { new: true }
  );

  if (!notebook) {
    return res
      .status(404)
      .json({ success: false, message: "Notebook not found" });
  }

  return ok(res, notebook, null, "Notebook updated successfully");
});

// ğŸ—‘ï¸ XÃ³a má»m notebook (soft delete - Ä‘Ã¡nh dáº¥u deleted)
export const deleteNotebook = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const notebook = await Notebook.findOneAndUpdate(
    { _id: id, user_id: req.user.id },
    { status: "deleted", deletedAt: new Date() },
    { new: true }
  );

  if (!notebook) {
    return res
      .status(404)
      .json({ success: false, message: "Notebook not found" });
  }

  return ok(
    res,
    { id: notebook._id, status: notebook.status },
    null,
    "Notebook deleted successfully"
  );
});

// â™»ï¸ KhÃ´i phá»¥c notebook Ä‘Ã£ xÃ³a
export const restoreNotebook = asyncHandler(async (req, res) => {
  const { id } = req.params;

  // Kiá»ƒm tra notebook cÃ³ tá»“n táº¡i vÃ  Ä‘Ã£ bá»‹ xÃ³a khÃ´ng
  const notebook = await Notebook.findOne({
    _id: id,
    user_id: req.user.id,
    status: "deleted",
  });

  if (!notebook) {
    return res
      .status(404)
      .json({ success: false, message: "Notebook not found or not deleted" });
  }

  // âœ… Láº¤Y USER Tá»ª DATABASE thay vÃ¬ dÃ¹ng req.user (token cÃ³ thá»ƒ cÅ©)
  const User = (await import("../models/User.js")).default;
  const currentUser = await User.findById(req.user.id);

  // Kiá»ƒm tra giá»›i háº¡n gÃ³i miá»…n phÃ­ trÆ°á»›c khi khÃ´i phá»¥c
  const userPlan =
    currentUser?.subscriptionPlan || currentUser?.plan || "basic";
  const isFree = userPlan === "basic" || userPlan === "free";

  console.log("ğŸ” Restore notebook - User plan from DB:", userPlan);
  console.log("ğŸ” Restore notebook - Is free plan:", isFree);

  if (isFree) {
    // Äáº¿m sá»‘ notebook active hiá»‡n táº¡i (khÃ´ng bao gá»“m deleted)
    const activeNotebooksCount = await Notebook.countDocuments({
      user_id: req.user.id,
      status: "active",
    });

    if (activeNotebooksCount >= 3) {
      return res.status(403).json({
        success: false,
        message:
          "KhÃ´ng thá»ƒ khÃ´i phá»¥c. GÃ³i miá»…n phÃ­ chá»‰ Ä‘Æ°á»£c cÃ³ tá»‘i Ä‘a 3 nháº­t kÃ½. Vui lÃ²ng xÃ³a má»™t nháº­t kÃ½ khÃ¡c hoáº·c nÃ¢ng cáº¥p lÃªn gÃ³i ThÃ´ng Minh.",
        code: "NOTEBOOK_LIMIT_EXCEEDED",
        currentCount: activeNotebooksCount,
        maxAllowed: 3,
      });
    }
  }

  // KhÃ´i phá»¥c notebook
  notebook.status = "active";
  notebook.deletedAt = undefined;
  await notebook.save();

  return ok(
    res,
    { id: notebook._id, status: notebook.status },
    null,
    "Notebook restored successfully"
  );
});

// ğŸ—‘ï¸ Láº¥y danh sÃ¡ch notebook Ä‘Ã£ xÃ³a
export const getDeletedNotebooks = asyncHandler(async (req, res) => {
  const notebooks = await Notebook.find({
    user_id: req.user.id,
    status: "deleted",
  })
    .populate("guide_id", "title category")
    .populate("template_id", "template_name plant_group")
    .sort({ deletedAt: -1 });

  return ok(
    res,
    notebooks,
    { count: notebooks.length },
    "Deleted notebooks fetched successfully"
  );
});

// ğŸ’€ XÃ³a vÄ©nh viá»…n notebook (hard delete)
export const permanentDeleteNotebook = asyncHandler(async (req, res) => {
  const { id } = req.params;

  const notebook = await Notebook.findOneAndDelete({
    _id: id,
    user_id: req.user.id,
    status: "deleted", // Chá»‰ cho phÃ©p xÃ³a vÄ©nh viá»…n notebook Ä‘Ã£ á»Ÿ tráº¡ng thÃ¡i deleted
  });

  if (!notebook) {
    return res.status(404).json({
      success: false,
      message: "Notebook not found or not in deleted status",
    });
  }

  return ok(res, { id: notebook._id }, null, "Notebook permanently deleted");
});

// ğŸ” TÃ¬m kiáº¿m notebook theo tá»« khÃ³a
export const searchNotebooks = asyncHandler(async (req, res) => {
  const { keyword } = req.query;

  if (!keyword) {
    return res
      .status(400)
      .json({ success: false, message: "Keyword is required" });
  }

  const notebooks = await Notebook.find({
    user_id: req.user.id,
    status: { $ne: "deleted" },
    $or: [
      { notebook_name: { $regex: keyword, $options: "i" } },
      { plant_type: { $regex: keyword, $options: "i" } },
      { description: { $regex: keyword, $options: "i" } },
    ],
  })
    .populate("guide_id", "title category difficulty")
    .populate("template_id", "template_name plant_group")
    .sort({ createdAt: -1 });

  const meta = { count: notebooks.length, keyword };
  return ok(res, notebooks, meta, "Search results fetched successfully");
});

// ğŸ§© Lá»c notebook theo tiÃªu chÃ­
export const filterNotebooks = asyncHandler(async (req, res) => {
  const { plant_type, status, min_progress, max_progress, sort_by, order } =
    req.query;

  const filter = {
    user_id: req.user.id,
    status: { $ne: "deleted" },
  };

  if (plant_type) filter.plant_type = { $regex: plant_type, $options: "i" };
  if (status && ["active", "archived"].includes(status)) filter.status = status;
  if (min_progress !== undefined || max_progress !== undefined) {
    filter.progress = {};
    if (min_progress !== undefined)
      filter.progress.$gte = parseInt(min_progress);
    if (max_progress !== undefined)
      filter.progress.$lte = parseInt(max_progress);
  }

  let sortOption = { createdAt: -1 };
  if (sort_by) {
    const sortOrder = order === "asc" ? 1 : -1;
    switch (sort_by) {
      case "name":
        sortOption = { notebook_name: sortOrder };
        break;
      case "progress":
        sortOption = { progress: sortOrder };
        break;
      case "created":
        sortOption = { createdAt: sortOrder };
        break;
      case "updated":
        sortOption = { updatedAt: sortOrder };
        break;
    }
  }

  const notebooks = await Notebook.find(filter)
    .populate("guide_id", "title category difficulty estimatedTime")
    .populate("template_id", "template_name plant_group status")
    .sort(sortOption);

  const meta = {
    count: notebooks.length,
    filter: {
      plant_type: plant_type || "all",
      status: status || "all except deleted",
      progress_range: { min: min_progress || 0, max: max_progress || 100 },
      sort_by: sort_by || "created",
      order: order || "desc",
    },
  };

  return ok(res, notebooks, meta, "Filtered notebooks fetched successfully");
});

// ğŸ–¼ï¸ ThÃªm áº£nh vÃ o notebook
export const addImage = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { image_url } = req.body;

  if (!image_url) {
    return res
      .status(400)
      .json({ success: false, message: "image_url is required" });
  }

  const notebook = await Notebook.findOne({
    _id: id,
    user_id: req.user.id,
    status: { $ne: "deleted" },
  });

  if (!notebook) {
    return res
      .status(404)
      .json({ success: false, message: "Notebook not found" });
  }

  notebook.images.push(image_url);
  await notebook.save();

  return ok(
    res,
    { images: notebook.images, total: notebook.images.length },
    null,
    "Image added successfully"
  );
});

// ğŸ§¹ XÃ³a áº£nh khá»i notebook
export const removeImage = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { image_url } = req.body;

  if (!image_url) {
    return res
      .status(400)
      .json({ success: false, message: "image_url is required" });
  }

  const notebook = await Notebook.findOne({
    _id: id,
    user_id: req.user.id,
    status: { $ne: "deleted" },
  });

  if (!notebook) {
    return res
      .status(404)
      .json({ success: false, message: "Notebook not found" });
  }

  notebook.images = notebook.images.filter((img) => img !== image_url);
  await notebook.save();

  return ok(
    res,
    { images: notebook.images, total: notebook.images.length },
    null,
    "Image removed successfully"
  );
});

// ğŸŒ± Láº¥y template phÃ¹ há»£p cho notebook
export const getNotebookTemplate = asyncHandler(async (req, res) => {
  const { id } = req.params;

  const template = await getTemplateForNotebook(id);

  if (!template) {
    return res
      .status(404)
      .json({ success: false, message: "No suitable template found" });
  }

  return ok(res, template, null, "Template fetched successfully");
});

// ğŸ“Œ GÃ¡n template cho notebook
export const assignTemplate = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { template_id } = req.body;

  if (!template_id) {
    return res
      .status(400)
      .json({ success: false, message: "template_id is required" });
  }

  const notebook = await assignTemplateToNotebook(id, template_id);

  return ok(res, notebook, null, "Template assigned successfully");
});

// ğŸ“Š Láº¥y timeline cá»§a notebook
export const getNotebookTimeline = asyncHandler(async (req, res) => {
  const { id } = req.params;

  // Validate ID
  if (!id || id === "undefined" || id === "null") {
    return res.status(400).json({
      success: false,
      message: "Invalid notebook ID",
    });
  }

  const notebook = await Notebook.findById(id).populate("template_id");

  if (!notebook || !notebook.template_id) {
    return ok(
      res,
      null,
      { hasTemplate: false },
      "Notebook chÆ°a cÃ³ template. Vui lÃ²ng gÃ¡n template Ä‘á»ƒ xem timeline."
    );
  }

  const template = notebook.template_id;

  const timeline = notebook.stages_tracking.map((tracking) => {
    const templateStage = template.stages.find(
      (s) => s.stage_number === tracking.stage_number
    );

    return {
      stage_number: tracking.stage_number,
      stage_name: tracking.stage_name,
      started_at: tracking.started_at,
      completed_at: tracking.completed_at,
      is_current: tracking.is_current,
      duration_days: templateStage
        ? templateStage.day_end - templateStage.day_start + 1
        : null,
      start_day: templateStage ? templateStage.day_start : null,
      end_day: templateStage ? templateStage.day_end : null,
      observations: tracking.observations,
    };
  });

  // ThÃªm ngÃ y hiá»ƒn thá»‹ (dá»±a trÃªn planted_date + template day_start/day_end)
  const timelineWithDates = timeline.map((t) => {
    const templateStage = template.stages.find(
      (s) => s.stage_number === t.stage_number
    );

    if (!templateStage) return t;

    const stageStart = getStageStartDate(
      notebook.planted_date,
      templateStage.day_start
    );
    const stageEnd = getStageEndDate(
      notebook.planted_date,
      templateStage.day_end
    );

    return {
      ...t,
      stage_start_date: formatVietnamDate(stageStart),
      stage_end_date: formatVietnamDate(stageEnd),
    };
  });

  const timelineData = {
    planted_date: notebook.planted_date,
    current_day: notebook.current_day,
    progress: notebook.progress,
    total_days: template.total_days,
    timeline: timelineWithDates,
  };

  return ok(
    res,
    timelineData,
    { timezone: "Asia/Ho_Chi_Minh (UTC+7)" },
    "Timeline fetched successfully"
  );
});

// âœ… Láº¥y daily checklist
export const getDailyChecklist = asyncHandler(async (req, res) => {
  const { id } = req.params;

  // Validate ID
  if (!id || id === "undefined" || id === "null") {
    return res.status(400).json({
      success: false,
      message: "Invalid notebook ID",
    });
  }

  const checklist = await generateDailyChecklist(id);

  // âœ… Return 200 with empty array instead of 404 for better UX
  if (!checklist) {
    return ok(
      res,
      [],
      {
        hasTemplate: false,
        timezone: "Asia/Ho_Chi_Minh (UTC+7)",
      },
      "Notebook chÆ°a cÃ³ template. Vui lÃ²ng gÃ¡n template Ä‘á»ƒ táº¡o checklist."
    );
  }

  // Kiá»ƒm tra xem stage cÃ³ Ä‘ang pending transition khÃ´ng
  const notebook = await Notebook.findById(id);
  const currentStageTracking = notebook?.stages_tracking?.find(
    (s) => s.stage_number === notebook.current_stage
  );

  const isPendingTransition = currentStageTracking?.pending_transition === true;

  return ok(
    res,
    checklist,
    {
      timezone: "Asia/Ho_Chi_Minh (UTC+7)",
      pending_transition: isPendingTransition,
      transition_message: isPendingTransition
        ? "CÃ´ng viá»‡c má»›i sáº½ xuáº¥t hiá»‡n vÃ o giai Ä‘oáº¡n má»›i vÃ o ngÃ y mai"
        : null,
    },
    "Daily checklist fetched successfully"
  );
});

// âœ”ï¸ ÄÃ¡nh dáº¥u hoÃ n thÃ nh task
export const completeTask = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { task_name } = req.body;

  if (!task_name) {
    return res
      .status(400)
      .json({ success: false, message: "task_name is required" });
  }

  const notebook = await completeChecklistTask(id, task_name);

  return ok(res, notebook.daily_checklist, null, "Task completed successfully");
});

// ğŸ”„ Cáº­p nháº­t stage hiá»‡n táº¡i
export const updateStage = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { stage_number } = req.body;

  if (!stage_number) {
    return res
      .status(400)
      .json({ success: false, message: "stage_number is required" });
  }

  const notebook = await updateCurrentStage(id, stage_number);

  return ok(res, notebook, null, "Stage updated successfully");
});

// ğŸ‘ï¸ Láº¥y observations cá»§a stage hiá»‡n táº¡i
export const getCurrentObservations = asyncHandler(async (req, res) => {
  const { id } = req.params;

  const observations = await getCurrentStageObservations(id);

  return ok(
    res,
    observations,
    null,
    "Current stage observations fetched successfully"
  );
});

// ğŸ“ Cáº­p nháº­t observation
export const updateObservation = asyncHandler(async (req, res) => {
  const { id } = req.params;
  // Accept multiple possible key names from different frontends
  const { observation_key, value } = req.body;
  const altKey =
    req.body.key || req.body.observationKey || req.body.observation_key;

  // Log request body for easier debugging in development
  if (process.env.NODE_ENV !== "production") {
    console.log("ğŸ”” updateObservation called", {
      notebookId: id,
      body: req.body,
    });
  }

  if (!altKey || value === undefined) {
    return res.status(400).json({
      success: false,
      message: "observation_key and value are required",
    });
  }

  // Normalize to observation_key variable
  const observationKey = altKey;

  const notebook = await updateStageObservation(id, observationKey, value);

  // Kiá»ƒm tra xem cÃ³ chuyá»ƒn stage khÃ´ng
  const currentStage = notebook.stages_tracking.find((s) => s.is_current);
  const previousStageNumber = req.body._previousStage || notebook.current_stage;

  if (currentStage && currentStage.stage_number > previousStageNumber) {
    return ok(
      res,
      notebook,
      {
        auto_transitioned: true,
        new_stage: currentStage.stage_number,
        stage_name: currentStage.stage_name,
      },
      `âœ… ÄÃ£ hoÃ n thÃ nh táº¥t cáº£ Ä‘iá»u kiá»‡n quan sÃ¡t! Tá»± Ä‘á»™ng chuyá»ƒn sang ${currentStage.stage_name}.`
    );
  }

  return ok(res, notebook, null, "Observation updated successfully");
});

// ğŸ” TÃ­nh stage hiá»‡n táº¡i dá»±a trÃªn sá»‘ ngÃ y
export const calculateStage = asyncHandler(async (req, res) => {
  const { id } = req.params;

  const stageInfo = await calculateCurrentStage(id);

  if (!stageInfo) {
    return res
      .status(404)
      .json({ success: false, message: "Cannot calculate stage" });
  }

  return ok(res, stageInfo, null, "Stage calculated successfully");
});

// ğŸ”„ Recalculate progress (debug endpoint)
export const recalculateProgress = asyncHandler(async (req, res) => {
  const { id } = req.params;

  const notebook = await Notebook.findOne({
    _id: id,
    user_id: req.user.id,
  }).populate("template_id");

  if (!notebook || !notebook.template_id) {
    return res.status(404).json({
      success: false,
      message: "Notebook not found or no template assigned",
    });
  }

  // Recalculate progress
  await notebook.updateProgress(notebook.template_id.stages);
  await notebook.save();

  const stageCompletion = await notebook.getCurrentStageCompletion();

  return ok(
    res,
    {
      progress: notebook.progress,
      stage_completion: stageCompletion,
      template_stages: notebook.template_id.stages.map((s) => ({
        stage_number: s.stage_number,
        name: s.name,
        weight:
          s.weight || Math.round(100 / notebook.template_id.stages.length),
      })),
      stages_tracking: notebook.stages_tracking.map((s) => ({
        stage_number: s.stage_number,
        stage_name: s.stage_name,
        is_current: s.is_current,
        completed: !!s.completed_at,
      })),
    },
    null,
    "Progress recalculated successfully"
  );
});

// ğŸ”§ Migrate old notebooks to add completed_tasks field
export const migrateNotebooks = asyncHandler(async (req, res) => {
  const notebooks = await Notebook.find({
    user_id: req.user.id,
  }).populate("template_id");

  let migratedCount = 0;

  for (const notebook of notebooks) {
    let needsSave = false;

    // Check each stage_tracking
    for (const stageTracking of notebook.stages_tracking) {
      // If no completed_tasks, initialize empty array
      if (!stageTracking.completed_tasks) {
        stageTracking.completed_tasks = [];
        needsSave = true;
      }
    }

    if (needsSave) {
      await notebook.save();
      migratedCount++;
      console.log(
        `âœ… Migrated notebook: ${notebook.notebook_name} (${notebook._id})`
      );
    }
  }

  return ok(
    res,
    {
      total: notebooks.length,
      migrated: migratedCount,
      already_updated: notebooks.length - migratedCount,
    },
    null,
    `Migration complete! ${migratedCount} notebook(s) updated`
  );
});

// ==========================================
// STAGE MONITORING EXPORTS
// ==========================================

// ğŸ” Kiá»ƒm tra má»™t notebook cá»¥ thá»ƒ (manual trigger)
export const checkSingleNotebook = asyncHandler(async (req, res) => {
  const { id } = req.params;

  const notebook = await Notebook.findById(id).populate("template_id");

  if (!notebook) {
    return res.status(404).json({
      success: false,
      message: "KhÃ´ng tÃ¬m tháº¥y notebook",
    });
  }

  await checkNotebookStageStatus(notebook);

  return ok(
    res,
    {
      notebook_id: notebook._id,
      notebook_name: notebook.notebook_name,
      current_stage: notebook.current_stage,
      stages_tracking: notebook.stages_tracking.map((s) => ({
        stage_number: s.stage_number,
        stage_name: s.stage_name,
        status: s.status,
        is_current: s.is_current,
      })),
    },
    null,
    "Notebook stage status checked successfully"
  );
});

// ğŸ”„ Monitor táº¥t cáº£ notebooks (admin/cron endpoint)
export const monitorAllNotebooks = asyncHandler(async (req, res) => {
  console.log("ğŸ” Báº¯t Ä‘áº§u monitor táº¥t cáº£ notebooks...");

  try {
    const notebooks = await Notebook.find({
      status: "active",
      template_id: { $exists: true, $ne: null },
    }).populate("template_id");

    console.log(`ğŸ“Š TÃ¬m tháº¥y ${notebooks.length} notebooks cáº§n kiá»ƒm tra`);

    for (const notebook of notebooks) {
      await checkNotebookStageStatus(notebook);
    }

    console.log("âœ… HoÃ n thÃ nh monitor táº¥t cáº£ notebooks");

    return ok(
      res,
      {
        total_checked: notebooks.length,
        timestamp: new Date(),
      },
      null,
      "All notebooks monitored successfully"
    );
  } catch (error) {
    console.error("âŒ Lá»—i khi monitor notebooks:", error);
    return res.status(500).json({
      success: false,
      message: "Error monitoring notebooks",
      error: error.message,
    });
  }
});

// ==========================================
// DAILY STATUS & OVERDUE MANAGEMENT
// ==========================================

// ğŸ“… Láº¥y tráº¡ng thÃ¡i hÃ ng ngÃ y (tasks hÃ´m nay + overdue summary)
export const getDailyStatus = asyncHandler(async (req, res) => {
  const { id } = req.params; // notebook_id

  const notebook = await Notebook.findOne({
    _id: id,
    user_id: req.user.id,
    status: { $ne: "deleted" },
  }).populate("template_id");

  if (!notebook) {
    return res.status(404).json({
      success: false,
      message: "Notebook not found",
    });
  }

  console.log(
    `ğŸ”” getDailyStatus called for notebook=${id} user=${req.user?.id}`
  );

  // Táº¡o checklist cho hÃ´m nay (sáº½ tá»± Ä‘á»™ng xá»­ lÃ½ overdue náº¿u sang ngÃ y má»›i)
  await generateDailyChecklist(id);

  // Reload notebook sau khi generate
  const updatedNotebook = await Notebook.findById(id).populate("template_id");

  const currentStageTracking = updatedNotebook.stages_tracking.find(
    (s) => s.stage_number === updatedNotebook.current_stage
  );

  const today = getVietnamToday();

  // âœ… Kiá»ƒm tra notebook Ä‘Ã£ hoÃ n thÃ nh 100% -> khÃ´ng tráº£ overdue summary
  const isNotebookCompleted =
    updatedNotebook.progress === 100 &&
    Array.isArray(updatedNotebook.stages_tracking) &&
    updatedNotebook.stages_tracking.length > 0 &&
    updatedNotebook.stages_tracking.every((s) => s.status === "completed");

  const overdueSummary =
    !isNotebookCompleted &&
    currentStageTracking?.overdue_summary?.ready_to_notify
      ? {
          overdue_date: currentStageTracking.overdue_summary.date,
          overdue_count: currentStageTracking.overdue_summary.overdue_count,
        }
      : null;

  return ok(
    res,
    {
      today: today.toISOString().split("T")[0],
      current_day: updatedNotebook.current_day,
      tasks_today: updatedNotebook.daily_checklist,
      overdue_summary: overdueSummary,
    },
    { timezone: "Asia/Ho_Chi_Minh (UTC+7)" },
    "Daily status fetched successfully"
  );
});

// ğŸ—‘ï¸ Bá» qua táº¥t cáº£ overdue tasks
export const skipOverdueTasks = asyncHandler(async (req, res) => {
  const { id } = req.params; // notebook_id

  const notebook = await Notebook.findOne({
    _id: id,
    user_id: req.user.id,
    status: { $ne: "deleted" },
  });

  if (!notebook) {
    return res.status(404).json({
      success: false,
      message: "Notebook not found",
    });
  }

  // ÄÃ¡nh dáº¥u táº¥t cáº£ overdue tasks (Ä‘Æ°á»£c lÆ°u trong stageTracking.overdue_tasks) = skipped
  const currentStageTracking = notebook.stages_tracking.find(
    (s) => s.stage_number === notebook.current_stage
  );

  if (!currentStageTracking || !currentStageTracking.overdue_tasks) {
    return ok(res, null, null, "No overdue tasks to skip");
  }

  const overdueTasks = currentStageTracking.overdue_tasks.filter(
    (t) => t.status === "overdue"
  );

  if (overdueTasks.length === 0) {
    return ok(res, null, null, "No overdue tasks to skip");
  }

  overdueTasks.forEach((t) => {
    t.status = "skipped";
    t.skipped_at = new Date();
  });

  // Reset overdue_summary notify flag
  if (currentStageTracking && currentStageTracking.overdue_summary) {
    currentStageTracking.overdue_summary.ready_to_notify = false;
    currentStageTracking.overdue_summary.notified_at = new Date();
  }

  await notebook.save();

  return ok(
    res,
    { skipped_count: overdueTasks.length },
    null,
    `${overdueTasks.length} overdue tasks skipped successfully`
  );
});

// âœ… HoÃ n thÃ nh má»™t overdue task (hoÃ n thÃ nh bÃ¹)
export const completeOverdueTask = asyncHandler(async (req, res) => {
  const { id } = req.params; // notebook_id
  const { task_name } = req.body;

  if (!task_name) {
    return res
      .status(400)
      .json({ success: false, message: "task_name is required" });
  }

  const notebook = await Notebook.findOne({
    _id: id,
    user_id: req.user.id,
    status: { $ne: "deleted" },
  }).populate("template_id");

  if (!notebook) {
    return res
      .status(404)
      .json({ success: false, message: "Notebook not found" });
  }

  const currentStageTracking = notebook.stages_tracking.find(
    (s) => s.stage_number === notebook.current_stage
  );

  if (!currentStageTracking || !currentStageTracking.overdue_tasks) {
    return res
      .status(404)
      .json({ success: false, message: "No overdue tasks found" });
  }

  const task = currentStageTracking.overdue_tasks.find(
    (t) =>
      (t.task_name || "").trim() === (task_name || "").trim() &&
      t.status === "overdue"
  );

  if (!task) {
    return res
      .status(404)
      .json({ success: false, message: "Overdue task not found" });
  }

  // Mark as completed
  task.is_completed = true;
  // If this is a makeup for an original date, attribute the completion to the
  // original date so it counts toward that day's daily_log.
  task.completed_at = task.original_date
    ? new Date(task.original_date)
    : new Date();
  task.status = "completed";

  // Add to completed_tasks for tracking (if not already)
  if (!currentStageTracking.completed_tasks) {
    currentStageTracking.completed_tasks = [];
  }
  const alreadyCompleted = currentStageTracking.completed_tasks.some(
    (t) => t.task_name === task_name
  );
  if (!alreadyCompleted) {
    const completedAtForRecord = task.original_date
      ? new Date(task.original_date)
      : new Date();
    currentStageTracking.completed_tasks.push({
      task_name,
      completed_at: completedAtForRecord,
    });
  }

  // Persist the change to overdue_tasks (marking the task completed) before
  // regenerating the daily checklist so DB reflects the updated status.
  await notebook.save();

  // Update today's daily_log progress to include this makeup completion
  // Ensure we have today's checklist generated so progress math is correct
  await generateDailyChecklist(notebook._id);

  // Reload notebook to get updated daily_checklist
  const refreshedNotebook = await Notebook.findById(notebook._id).populate(
    "template_id"
  );

  const todayDate = getVietnamToday();
  const today = todayDate.toISOString().split("T")[0];

  const refreshedStageTracking = refreshedNotebook.stages_tracking.find(
    (s) => s.stage_number === refreshedNotebook.current_stage
  );

  if (!refreshedStageTracking.daily_logs)
    refreshedStageTracking.daily_logs = [];

  let dailyLog = refreshedStageTracking.daily_logs.find(
    (log) => log.date?.toISOString().split("T")[0] === today
  );

  if (!dailyLog) {
    dailyLog = { date: todayDate, daily_progress: 0 };
    refreshedStageTracking.daily_logs.push(dailyLog);
  }

  // Compute new daily progress: existing completed today + this makeup / total today tasks
  const todayTasks = refreshedNotebook.daily_checklist || [];
  const completedTodayTasks = todayTasks.filter((t) => t.is_completed).length;
  const totalTodayTasks = todayTasks.length || 0;

  if (totalTodayTasks > 0) {
    // Use the actual completed tasks count for today's progress. The previous
    // implementation added `+1` to account for the makeup completion, but
    // generateDailyChecklist already marks makeup tasks as completed for
    // today when `completed_at` is set to today. Adding +1 caused
    // overcounting or incorrect daily_logs when the task was present in
    // today's checklist. Use the straightforward ratio instead.
    dailyLog.daily_progress = Math.round(
      (completedTodayTasks / totalTodayTasks) * 100
    );
  } else {
    // If no daily tasks today, conservatively set a small progress increment (e.g., 10%)
    dailyLog.daily_progress = Math.min(
      100,
      (dailyLog.daily_progress || 0) + 10
    );
  }

  // âš ï¸ KHÃ”NG cáº­p nháº­t progress khi hoÃ n thÃ nh overdue task
  // Progress chá»‰ Ä‘Æ°á»£c cáº­p nháº­t khi hoÃ n thÃ nh táº¥t cáº£ observations á»Ÿ cuá»‘i giai Ä‘oáº¡n
  console.log(
    `â„¹ï¸ Overdue task completed. Progress will update only when observations are completed.`
  );
  // Recompute overdue_summary count and notify flag
  const remainingOverdue = currentStageTracking.overdue_tasks.filter(
    (t) => t.status === "overdue"
  ).length;

  if (!refreshedStageTracking.overdue_summary) {
    refreshedStageTracking.overdue_summary = {
      date: null,
      overdue_count: 0,
      ready_to_notify: false,
    };
  }

  refreshedStageTracking.overdue_summary.overdue_count = remainingOverdue;
  if (remainingOverdue === 0) {
    refreshedStageTracking.overdue_summary.ready_to_notify = false;
    refreshedStageTracking.overdue_summary.notified_at = new Date();
  }

  // Also update daily_log for the original date of the overdue task we just completed.
  try {
    const completedOverdue = refreshedStageTracking.overdue_tasks.find(
      (t) => t.task_name === task_name && t.status === "completed"
    );
    if (completedOverdue && completedOverdue.original_date) {
      const origKey = toVietnamMidnight(
        new Date(completedOverdue.original_date)
      )
        .toISOString()
        .split("T")[0];

      if (!refreshedStageTracking.daily_logs)
        refreshedStageTracking.daily_logs = [];

      let origLog = refreshedStageTracking.daily_logs.find(
        (log) =>
          toVietnamMidnight(new Date(log.date)).toISOString().split("T")[0] ===
          origKey
      );

      if (!origLog) {
        origLog = {
          date: toVietnamMidnight(new Date(completedOverdue.original_date)),
          daily_progress: 0,
        };
        refreshedStageTracking.daily_logs.push(origLog);
      }

      // Count overdue items that belong to this original date
      const related = refreshedStageTracking.overdue_tasks.filter(
        (ot) =>
          toVietnamMidnight(new Date(ot.original_date))
            .toISOString()
            .split("T")[0] === origKey
      );
      const completedCount = related.filter(
        (r) => r.status === "completed"
      ).length;
      const totalCount = related.length || 1;

      origLog.daily_progress = Math.round((completedCount / totalCount) * 100);
    }
  } catch (e) {
    console.warn(
      "Failed to update original-date daily_log for overdue completion:",
      e
    );
  }

  await refreshedNotebook.save();

  return ok(
    res,
    {
      notebook_id: refreshedNotebook._id,
      stage_completion: await refreshedNotebook.getCurrentStageCompletion(),
      progress: refreshedNotebook.progress,
    },
    null,
    "Overdue task completed successfully"
  );
});

// âœ… HoÃ n thÃ nh nhiá»u overdue tasks cÃ¹ng lÃºc
export const completeOverdueTasksBulk = asyncHandler(async (req, res) => {
  const { id } = req.params; // notebook_id
  const { task_names } = req.body;

  if (!task_names || !Array.isArray(task_names) || task_names.length === 0) {
    return res
      .status(400)
      .json({ success: false, message: "task_names (array) is required" });
  }

  const notebook = await Notebook.findOne({
    _id: id,
    user_id: req.user.id,
    status: { $ne: "deleted" },
  }).populate("template_id");

  if (!notebook) {
    return res
      .status(404)
      .json({ success: false, message: "Notebook not found" });
  }

  const currentStageTracking = notebook.stages_tracking.find(
    (s) => s.stage_number === notebook.current_stage
  );

  if (!currentStageTracking || !currentStageTracking.overdue_tasks) {
    return res
      .status(404)
      .json({ success: false, message: "No overdue tasks found" });
  }

  const toComplete = task_names.map((name) => name.trim());
  const completedNow = [];

  toComplete.forEach((taskName) => {
    const task = currentStageTracking.overdue_tasks.find(
      (t) =>
        (t.task_name || "").trim() === (taskName || "").trim() &&
        t.status === "overdue"
    );
    if (task) {
      task.is_completed = true;
      task.completed_at = task.original_date
        ? new Date(task.original_date)
        : new Date();
      task.status = "completed";

      if (!currentStageTracking.completed_tasks)
        currentStageTracking.completed_tasks = [];
      const already = currentStageTracking.completed_tasks.some(
        (t) => t.task_name === taskName
      );
      if (!already) {
        const completedAtForRecord = task.original_date
          ? new Date(task.original_date)
          : new Date();
        currentStageTracking.completed_tasks.push({
          task_name: taskName,
          completed_at: completedAtForRecord,
        });
      }

      completedNow.push(taskName);
    }
  });
  // Persist changes to the notebook (marking overdue tasks completed)
  await notebook.save();

  // Regenerate checklist once
  await generateDailyChecklist(notebook._id);

  // Reload notebook
  const refreshedNotebook = await Notebook.findById(notebook._id).populate(
    "template_id"
  );

  const todayDate = getVietnamToday();
  const today = todayDate.toISOString().split("T")[0];

  const refreshedStageTracking = refreshedNotebook.stages_tracking.find(
    (s) => s.stage_number === refreshedNotebook.current_stage
  );

  if (!refreshedStageTracking.daily_logs)
    refreshedStageTracking.daily_logs = [];

  let dailyLog = refreshedStageTracking.daily_logs.find(
    (log) => log.date?.toISOString().split("T")[0] === today
  );
  if (!dailyLog) {
    dailyLog = { date: todayDate, daily_progress: 0 };
    refreshedStageTracking.daily_logs.push(dailyLog);
  }

  const todayTasks = refreshedNotebook.daily_checklist || [];
  const completedTodayTasks = todayTasks.filter((t) => t.is_completed).length;
  const totalTodayTasks = todayTasks.length || 0;

  if (totalTodayTasks > 0) {
    dailyLog.daily_progress = Math.round(
      (completedTodayTasks / totalTodayTasks) * 100
    );
  }

  // âš ï¸ KHÃ”NG cáº­p nháº­t progress khi hoÃ n thÃ nh bulk overdue tasks
  // Progress chá»‰ Ä‘Æ°á»£c cáº­p nháº­t khi hoÃ n thÃ nh observations á»Ÿ cuá»‘i giai Ä‘oáº¡n
  console.log(
    `â„¹ï¸ ${completedNow} overdue tasks completed. Progress will update only when observations are completed.`
  );

  // Recompute overdue_summary
  const remainingOverdue = currentStageTracking.overdue_tasks.filter(
    (t) => t.status === "overdue"
  ).length;
  if (!refreshedStageTracking.overdue_summary)
    refreshedStageTracking.overdue_summary = {
      date: null,
      overdue_count: 0,
      ready_to_notify: false,
    };
  refreshedStageTracking.overdue_summary.overdue_count = remainingOverdue;
  if (remainingOverdue === 0) {
    refreshedStageTracking.overdue_summary.ready_to_notify = false;
    refreshedStageTracking.overdue_summary.notified_at = new Date();
  }

  await refreshedNotebook.save();

  return ok(
    res,
    {
      notebook_id: refreshedNotebook._id,
      completed: completedNow,
      stage_completion: await refreshedNotebook.getCurrentStageCompletion(),
      progress: refreshedNotebook.progress,
    },
    null,
    "Bulk overdue tasks completed successfully"
  );
});

// ğŸ“‹ Láº¥y chi tiáº¿t overdue tasks
export const getOverdueDetail = asyncHandler(async (req, res) => {
  const { id } = req.params; // notebook_id

  const notebook = await Notebook.findOne({
    _id: id,
    user_id: req.user.id,
    status: { $ne: "deleted" },
  });

  if (!notebook) {
    return res.status(404).json({
      success: false,
      message: "Notebook not found",
    });
  }

  console.log(
    `ğŸ”” getOverdueDetail called for notebook=${id} user=${req.user?.id}`
  );

  const currentStageTracking = notebook.stages_tracking.find(
    (s) => s.stage_number === notebook.current_stage
  );

  const allOverdueTasks = currentStageTracking?.overdue_tasks || [];
  // Return only tasks that are still in 'overdue' status. Completed/skipped
  // entries remain in the array for history but should not be counted as active overdue.
  const activeOverdueTasks = allOverdueTasks.filter(
    (t) => t.status === "overdue"
  );

  console.log(
    `ğŸ” Overdue tasks for notebook=${id} stage=${notebook.current_stage}: persisted=${allOverdueTasks.length} active=${activeOverdueTasks.length}`
  );

  // Group active overdue tasks by their original_date (the date the checklist belonged to)
  // and exclude tasks whose original_date is today (these are tasks that became overdue today
  // and the user indicated today's tasks are not relevant for overdue history notifications).
  const todayMid = toVietnamMidnight(getVietnamToday());

  const groupsMap = {};
  activeOverdueTasks.forEach((t) => {
    // original_date may be stored as Date or string
    const orig = t.original_date
      ? toVietnamMidnight(new Date(t.original_date))
      : null;

    // If original_date equals today, skip grouping (we will not include today's original_date tasks)
    if (orig && orig.getTime() === todayMid.getTime()) return;

    const key = orig ? orig.toISOString().split("T")[0] : "unknown";
    if (!groupsMap[key]) groupsMap[key] = { date: orig, tasks: [] };
    groupsMap[key].tasks.push(t);
  });

  // Convert groupsMap to sorted array by date ascending
  const overdue_groups = Object.keys(groupsMap)
    .map((k) => ({ date: groupsMap[k].date, tasks: groupsMap[k].tasks }))
    .sort((a, b) => {
      if (!a.date) return 1;
      if (!b.date) return -1;
      return a.date.getTime() - b.date.getTime();
    });

  // Total active overdue count excluding today's original_date tasks
  const overdue_count = overdue_groups.reduce((s, g) => s + g.tasks.length, 0);

  return ok(
    res,
    {
      // keep backward-compatible fields
      overdue_date: currentStageTracking?.overdue_summary?.date || null,
      overdue_count,
      overdue_tasks: activeOverdueTasks,
      overdue_groups,
    },
    null,
    "Overdue tasks detail fetched successfully"
  );
});

// =====================
// Notebook statistics
// =====================
export const getStats = asyncHandler(async (req, res) => {
  const userId = req.user?.id;

  const match = { status: { $ne: "deleted" } };
  if (userId) match.user_id = new mongoose.Types.ObjectId(userId);

  // By type
  const byTypeAgg = await Notebook.aggregate([
    { $match: match },
    { $group: { _id: "$plant_type", count: { $sum: 1 } } },
    { $sort: { count: -1 } },
  ]);

  // By group
  const byGroupAgg = await Notebook.aggregate([
    { $match: match },
    { $group: { _id: "$plant_group", count: { $sum: 1 } } },
    { $sort: { count: -1 } },
  ]);

  // Average progress
  const progressAgg = await Notebook.aggregate([
    { $match: match },
    { $group: { _id: null, avgProgress: { $avg: "$progress" } } },
  ]);

  const avgProgress = progressAgg[0]?.avgProgress ?? 0;

  // Progress distribution
  const distributionAgg = await Notebook.aggregate([
    { $match: match },
    {
      $bucket: {
        groupBy: "$progress",
        boundaries: [0, 25, 50, 75, 100, 101],
        default: "unknown",
        output: { count: { $sum: 1 } },
      },
    },
  ]);

  const progressDistribution = {
    "0-25": 0,
    "25-50": 0,
    "50-75": 0,
    "75-100": 0,
  };
  distributionAgg.forEach((b) => {
    const key = b._id;
    if (key === 0) progressDistribution["0-25"] = b.count;
    else if (key === 25) progressDistribution["25-50"] = b.count;
    else if (key === 50) progressDistribution["50-75"] = b.count;
    else if (key === 75) progressDistribution["75-100"] = b.count;
  });

  // Most popular type
  const mostPopularType = byTypeAgg.length > 0 ? byTypeAgg[0]._id : null;

  // Average grow days (planted_date -> max completed_at)
  const avgGrowAgg = await Notebook.aggregate([
    { $match: match },
    {
      $addFields: { maxCompletedAt: { $max: "$stages_tracking.completed_at" } },
    },
    {
      $match: {
        planted_date: { $exists: true, $ne: null },
        maxCompletedAt: { $exists: true, $ne: null },
      },
    },
    {
      $project: {
        diffDays: {
          $divide: [
            { $subtract: ["$maxCompletedAt", "$planted_date"] },
            1000 * 60 * 60 * 24,
          ],
        },
      },
    },
    { $group: { _id: null, avgGrowDays: { $avg: "$diffDays" } } },
  ]);

  const avgGrowDays = avgGrowAgg[0]?.avgGrowDays ?? null;

  const byType = {};
  byTypeAgg.forEach((r) => (byType[r._id || "Unknown"] = r.count));

  const byGroup = {};
  byGroupAgg.forEach((r) => (byGroup[r._id || "unknown"] = r.count));

  const result = {
    byType,
    byGroup,
    mostPopularType,
    progressAvg: Math.round(avgProgress),
    progressDistribution,
    avgGrowDays: avgGrowDays ? Math.round(avgGrowDays) : null,
  };

  return ok(res, result, null, "Notebook statistics fetched successfully");
});
