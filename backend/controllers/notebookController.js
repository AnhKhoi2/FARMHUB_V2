import Notebook from "../models/Notebook.js";
import mongoose from "mongoose";
import Guide from "../models/Guide.js";
import PlantTemplate from "../models/PlantTemplate.js";
import { ok, created, noContent } from "../utils/ApiResponse.js";
import { asyncHandler } from "../utils/asyncHandler.js";
import { AppError } from "../utils/AppError.js";
import {
  sendStageWarningNotification,
  sendStageSkippedNotification,
  sendStageOverdueNotification,
} from "./notificationController.js";
import {
  getDaysDifferenceVN,
  toVietnamMidnight,
  getVietnamToday,
} from "../utils/timezone.js";

// ==========================================
// HELPER FUNCTIONS (from services)
// ==========================================

/**
 * TÃ­nh sá»‘ ngÃ y tá»« startDate Ä‘áº¿n endDate (theo giá» Viá»‡t Nam UTC+7)
 * Sá»­ dá»¥ng helper tá»« timezone.js
 */
const getDaysDifference = getDaysDifferenceVN;

/**
 * TÃ­nh stage end date dá»±a trÃªn planted_date vÃ  stage.day_end (theo giá» Viá»‡t Nam UTC+7)
 */
const getStageEndDate = (plantedDate, stageEndDay) => {
  const endDate = new Date(plantedDate);
  endDate.setDate(endDate.getDate() + stageEndDay - 1);
  return toVietnamMidnight(endDate);
};

/**
 * Kiá»ƒm tra xem notification Ä‘Ã£ Ä‘Æ°á»£c gá»­i chÆ°a
 */
const hasNotificationBeenSent = (notificationsSent, type, missedDay) => {
  return notificationsSent?.some((n) => n.type === type && n.day === missedDay);
};

/**
 * Láº¥y template phÃ¹ há»£p vá»›i notebook (dá»±a trÃªn guide's plant_group)
 */
const getTemplateForNotebook = async (notebookId) => {
  const notebook = await Notebook.findById(notebookId).populate("guide_id");

  if (!notebook) {
    throw new AppError("KhÃ´ng tÃ¬m tháº¥y nháº­t kÃ½", 404);
  }

  if (notebook.template_id) {
    const template = await PlantTemplate.findById(notebook.template_id);
    return template;
  }

  if (notebook.guide_id && notebook.guide_id.plant_group) {
    const template = await PlantTemplate.findOne({
      plant_group: notebook.guide_id.plant_group,
      status: "active",
    }).sort({ usage_count: -1 });

    return template;
  }

  return null;
};

/**
 * GÃ¡n template cho notebook
 */
const assignTemplateToNotebook = async (notebookId, templateId) => {
  const notebook = await Notebook.findById(notebookId);
  const template = await PlantTemplate.findById(templateId);

  if (!notebook) {
    throw new AppError("KhÃ´ng tÃ¬m tháº¥y nháº­t kÃ½", 404);
  }

  if (!template) {
    throw new AppError("KhÃ´ng tÃ¬m tháº¥y template", 404);
  }

  notebook.template_id = templateId;

  notebook.stages_tracking = template.stages.map((stage, index) => ({
    stage_number: stage.stage_number,
    stage_name: stage.name,
    started_at: index === 0 ? notebook.planted_date : null,
    is_current: index === 0,
  }));

  notebook.current_stage = 1;

  await notebook.updateProgress(template.stages);

  await notebook.save();

  template.usage_count += 1;
  await template.save();

  await generateDailyChecklist(notebookId);

  return notebook;
};

/**
 * Táº¡o daily checklist tá»« template's autogenerated_tasks
 */
export const generateDailyChecklist = async (notebookId) => {
  const notebook = await Notebook.findById(notebookId).populate("template_id");

  if (!notebook || !notebook.template_id) {
    return null;
  }

  const template = notebook.template_id;
  const currentStage = template.stages.find(
    (s) => s.stage_number === notebook.current_stage
  );

  if (!currentStage) {
    return null;
  }

  const today = getVietnamToday();

  // Kiá»ƒm tra xem Ä‘Ã£ Ä‘áº¿n ngÃ y báº¯t Ä‘áº§u cá»§a stage chÆ°a
  const currentDay = notebook.current_day || 1;
  if (currentDay < currentStage.day_start) {
    console.log(
      `â³ Stage ${notebook.current_stage} chÆ°a báº¯t Ä‘áº§u (current_day: ${currentDay}, day_start: ${currentStage.day_start})`
    );
    // Tráº£ vá» checklist rá»—ng vÃ¬ chÆ°a Ä‘áº¿n ngÃ y báº¯t Ä‘áº§u stage
    notebook.daily_checklist = [];
    notebook.last_checklist_generated = today;
    await notebook.save();
    return [];
  }

  // Kiá»ƒm tra náº¿u Ä‘Ã£ táº¡o checklist hÃ´m nay rá»“i
  const lastGenerated = notebook.last_checklist_generated
    ? toVietnamMidnight(notebook.last_checklist_generated)
    : null;

  if (lastGenerated && lastGenerated.getTime() === today.getTime()) {
    return notebook.daily_checklist;
  }

  // âœ… SANG NGÃ€Y Má»šI â†’ Xá»­ lÃ½ overdue cho tasks ngÃ y hÃ´m qua
  if (lastGenerated && lastGenerated.getTime() < today.getTime()) {
    const currentStageTracking = notebook.stages_tracking.find(
      (s) => s.stage_number === notebook.current_stage
    );

    if (currentStageTracking) {
      // Äáº¿m sá»‘ task chÆ°a hoÃ n thÃ nh cá»§a ngÃ y hÃ´m qua
      const incompleteTasks = notebook.daily_checklist.filter(
        (task) => !task.is_completed && task.status === "pending"
      );

      if (incompleteTasks.length > 0) {
        console.log(
          `âš ï¸ Found ${incompleteTasks.length} incomplete tasks on ${
            lastGenerated.toISOString().split("T")[0]
          } â€” moving to overdue_tasks`
        );

        // Initialize overdue_tasks array if missing
        if (!currentStageTracking.overdue_tasks) {
          currentStageTracking.overdue_tasks = [];
        }

        // Move each incomplete task into stageTracking.overdue_tasks
        incompleteTasks.forEach((task) => {
          currentStageTracking.overdue_tasks.push({
            task_name: task.task_name,
            description: task.description,
            priority: task.priority || "medium",
            frequency: task.frequency || "daily",
            is_completed: task.is_completed || false,
            original_date: lastGenerated,
            status: "overdue",
            overdue_at: today,
          });
        });

        // Log moved task names for debugging
        console.log(
          `â¡ï¸ Moved tasks to overdue: ${incompleteTasks
            .map((t) => t.task_name)
            .join(", ")}`
        );

        // LÆ°u overdue_summary (use total persisted overdue_tasks length to avoid overwriting previous counts)
        const totalOverdueCount = currentStageTracking.overdue_tasks.length;
        currentStageTracking.overdue_summary = {
          date: lastGenerated,
          overdue_count: totalOverdueCount,
          ready_to_notify: true,
        };

        console.log(
          `ğŸ“Š Overdue summary saved: ${totalOverdueCount} total overdue tasks (added ${incompleteTasks.length})`
        );
      }
    }
  }

  const daysInStage =
    Math.floor(notebook.current_day) - currentStage.day_start + 1;

  const currentStageTracking = notebook.stages_tracking
    ? notebook.stages_tracking.find(
        (s) => s.stage_number === notebook.current_stage
      )
    : null;

  const newChecklist = (
    currentStage.autogenerated_tasks ||
    currentStage.daily_tasks ||
    []
  )
    .filter((task) => {
      // Always show daily tasks
      if (task.frequency === "daily") return true;

      // One-time tasks: show only on first day of stage if not already completed
      if (task.frequency === "once") {
        const alreadyCompleted = currentStageTracking?.completed_tasks?.some(
          (t) => t.task_name === task.task_name
        );
        return !alreadyCompleted && daysInStage === 1;
      }

      // Interval-based tasks: prefer last completion date if available
      const intervalMap = {
        every_2_days: 2,
        every_3_days: 3,
        weekly: 7,
      };

      const interval = intervalMap[task.frequency];
      if (!interval) return false;

      // Find last completed entry for this task in current stage
      const lastCompleted = currentStageTracking?.completed_tasks
        ? currentStageTracking.completed_tasks
            .filter((t) => t.task_name === task.task_name)
            .reduce((latest, t) => {
              if (!latest) return t;
              return new Date(t.completed_at) > new Date(latest.completed_at)
                ? t
                : latest;
            }, null)
        : null;

      if (lastCompleted && lastCompleted.completed_at) {
        const daysSinceLast = getDaysDifference(
          lastCompleted.completed_at,
          today
        );
        // Show when days since last completion is >= interval and matches the interval cadence
        return daysSinceLast >= interval && daysSinceLast % interval === 0;
      }

      // Fallback to original stage-based cadence if never completed in this stage
      return daysInStage % interval === 0;
    })
    .map((task) => ({
      task_name: task.task_name,
      description: task.description,
      priority: task.priority,
      frequency: task.frequency,
      is_completed: false,
      status: "pending", // âœ… Set default status
    }));

  notebook.daily_checklist = newChecklist;
  notebook.last_checklist_generated = today;
  await notebook.save();

  return newChecklist;
};

/**
 * Cáº­p nháº­t stage hiá»‡n táº¡i
 */
const updateCurrentStage = async (notebookId, newStageNumber) => {
  const notebook = await Notebook.findById(notebookId).populate("template_id");

  if (!notebook || !notebook.template_id) {
    throw new AppError("KhÃ´ng tÃ¬m tháº¥y nháº­t kÃ½ hoáº·c template", 404);
  }

  const template = notebook.template_id;

  if (newStageNumber > template.stages.length) {
    throw new AppError("Sá»‘ stage khÃ´ng há»£p lá»‡", 400);
  }

  const oldStageIndex = notebook.stages_tracking.findIndex(
    (s) => s.stage_number === notebook.current_stage
  );
  if (oldStageIndex !== -1) {
    notebook.stages_tracking[oldStageIndex].is_current = false;
    notebook.stages_tracking[oldStageIndex].completed_at = new Date();
  }

  const newStageIndex = notebook.stages_tracking.findIndex(
    (s) => s.stage_number === newStageNumber
  );
  if (newStageIndex !== -1) {
    notebook.stages_tracking[newStageIndex].is_current = true;
    notebook.stages_tracking[newStageIndex].started_at = new Date();
  }

  notebook.current_stage = newStageNumber;

  await notebook.updateProgress(template.stages);

  await notebook.save();

  await generateDailyChecklist(notebookId);

  return notebook;
};

/**
 * Kiá»ƒm tra vÃ  xá»­ lÃ½ tráº¡ng thÃ¡i stage cá»§a notebook (stage monitoring)
 */
export const checkNotebookStageStatus = async (notebook) => {
  try {
    if (!notebook.populated("template_id")) {
      await notebook.populate("template_id");
    }

    if (!notebook.template_id || !notebook.template_id.stages) {
      console.log(`âš ï¸ Notebook ${notebook._id} khÃ´ng cÃ³ template`);
      return;
    }

    const template = notebook.template_id;
    const today = getVietnamToday();

    const currentStageTracking = notebook.stages_tracking.find(
      (s) => s.stage_number === notebook.current_stage
    );

    if (!currentStageTracking) {
      console.log(
        `âš ï¸ KhÃ´ng tÃ¬m tháº¥y stage_tracking cho stage ${notebook.current_stage}`
      );
      return;
    }

    if (
      currentStageTracking.status === "completed" ||
      currentStageTracking.status === "skipped"
    ) {
      console.log(
        `âœ… Stage ${notebook.current_stage} Ä‘Ã£ ${currentStageTracking.status}, bá» qua`
      );
      return;
    }

    const templateStage = template.stages.find(
      (s) => s.stage_number === notebook.current_stage
    );

    if (!templateStage) {
      console.log(
        `âš ï¸ KhÃ´ng tÃ¬m tháº¥y template stage cho stage ${notebook.current_stage}`
      );
      return;
    }

    const stageEndDate = getStageEndDate(
      notebook.planted_date,
      templateStage.day_end
    );
    const daysAfterEnd = getDaysDifference(stageEndDate, today);

    console.log(
      `ğŸ“… Notebook: ${notebook.notebook_name} | Stage: ${
        templateStage.name
      } | End Date: ${
        stageEndDate.toISOString().split("T")[0]
      } | Days After End: ${daysAfterEnd}`
    );

    if (daysAfterEnd <= 0) {
      console.log(`âœ… Stage ${notebook.current_stage} cÃ²n trong thá»i háº¡n`);
      return;
    }

    const missedDays = daysAfterEnd;
    const safeDelayDays = template.rules?.safe_delay_days || 2;
    const autoSkip = template.rules?.auto_skip ?? true;

    console.log(
      `âš ï¸ Stage ${notebook.current_stage} Ä‘Ã£ trá»… ${missedDays} ngÃ y (safe_delay: ${safeDelayDays})`
    );

    currentStageTracking.missed_days = missedDays;

    if (missedDays <= safeDelayDays) {
      if (
        !hasNotificationBeenSent(
          currentStageTracking.notifications_sent,
          "warning",
          missedDays
        )
      ) {
        await sendStageWarningNotification({
          userId: notebook.user_id,
          notebookId: notebook._id,
          notebookName: notebook.notebook_name,
          stageNumber: notebook.current_stage,
          stageName: templateStage.name,
          missedDays,
          safeDelayDays,
        });

        if (!currentStageTracking.notifications_sent) {
          currentStageTracking.notifications_sent = [];
        }
        currentStageTracking.notifications_sent.push({
          type: "warning",
          day: missedDays,
          sent_at: new Date(),
        });

        if (currentStageTracking.status !== "overdue") {
          currentStageTracking.status = "overdue";
        }

        await notebook.save();
        console.log(
          `ğŸ“§ ÄÃ£ gá»­i cáº£nh bÃ¡o láº§n ${missedDays} cho stage ${notebook.current_stage}`
        );
      } else {
        console.log(`â­ï¸ ÄÃ£ gá»­i cáº£nh bÃ¡o cho missedDay ${missedDays}, bá» qua`);
      }
    } else {
      if (
        !hasNotificationBeenSent(
          currentStageTracking.notifications_sent,
          "exceeded",
          missedDays
        )
      ) {
        if (autoSkip) {
          currentStageTracking.status = "skipped";
          currentStageTracking.completed_at = new Date();
          currentStageTracking.is_current = false;

          await sendStageSkippedNotification({
            userId: notebook.user_id,
            notebookId: notebook._id,
            notebookName: notebook.notebook_name,
            stageNumber: notebook.current_stage,
            stageName: templateStage.name,
            missedDays,
            safeDelayDays,
          });

          const nextStageNumber = notebook.current_stage + 1;
          if (nextStageNumber <= template.stages.length) {
            const nextStageTracking = notebook.stages_tracking.find(
              (s) => s.stage_number === nextStageNumber
            );
            if (nextStageTracking) {
              nextStageTracking.is_current = true;
              nextStageTracking.started_at = new Date();
              nextStageTracking.status = "active";
            }
            notebook.current_stage = nextStageNumber;

            console.log(
              `â­ï¸ Tá»± Ä‘á»™ng skip stage ${templateStage.stage_number}, chuyá»ƒn sang stage ${nextStageNumber}`
            );
          } else {
            console.log(`ğŸ ÄÃ£ háº¿t stage, khÃ´ng thá»ƒ chuyá»ƒn stage tiáº¿p theo`);
          }

          if (!currentStageTracking.notifications_sent) {
            currentStageTracking.notifications_sent = [];
          }
          currentStageTracking.notifications_sent.push({
            type: "exceeded",
            day: missedDays,
            sent_at: new Date(),
          });

          await notebook.save();
        } else {
          currentStageTracking.status = "overdue";

          await sendStageOverdueNotification({
            userId: notebook.user_id,
            notebookId: notebook._id,
            notebookName: notebook.notebook_name,
            stageNumber: notebook.current_stage,
            stageName: templateStage.name,
            missedDays,
            safeDelayDays,
          });

          if (!currentStageTracking.notifications_sent) {
            currentStageTracking.notifications_sent = [];
          }
          currentStageTracking.notifications_sent.push({
            type: "exceeded",
            day: missedDays,
            sent_at: new Date(),
          });

          await notebook.save();
          console.log(
            `ğŸš¨ Stage ${notebook.current_stage} Ä‘Ã£ quÃ¡ háº¡n, yÃªu cáº§u can thiá»‡p thá»§ cÃ´ng`
          );
        }
      } else {
        console.log(`â­ï¸ ÄÃ£ xá»­ lÃ½ exceeded cho missedDay ${missedDays}, bá» qua`);
      }
    }
  } catch (error) {
    console.error(`âŒ Lá»—i khi check notebook ${notebook._id}:`, error);
  }
};

/**
 * ÄÃ¡nh dáº¥u hoÃ n thÃ nh task trong checklist
 */
const completeChecklistTask = async (notebookId, taskName) => {
  const notebook = await Notebook.findById(notebookId).populate("template_id");

  if (!notebook) {
    throw new AppError("KhÃ´ng tÃ¬m tháº¥y nháº­t kÃ½", 404);
  }

  const task = notebook.daily_checklist.find((t) => t.task_name === taskName);

  if (!task) {
    throw new AppError("KhÃ´ng tÃ¬m tháº¥y cÃ´ng viá»‡c", 404);
  }

  task.is_completed = !task.is_completed;
  task.completed_at = task.is_completed ? new Date() : null;
  task.status = task.is_completed ? "completed" : "pending"; // âœ… Update status

  const currentStageTracking = notebook.stages_tracking.find(
    (s) => s.stage_number === notebook.current_stage
  );

  if (currentStageTracking) {
    if (task.is_completed) {
      const alreadyCompleted = currentStageTracking.completed_tasks?.some(
        (t) => t.task_name === taskName
      );

      if (!alreadyCompleted) {
        if (!currentStageTracking.completed_tasks) {
          currentStageTracking.completed_tasks = [];
        }
        currentStageTracking.completed_tasks.push({
          task_name: taskName,
          completed_at: new Date(),
        });
      }
    } else {
      if (currentStageTracking.completed_tasks) {
        currentStageTracking.completed_tasks =
          currentStageTracking.completed_tasks.filter(
            (t) => t.task_name !== taskName
          );
      }
    }
  }

  if (notebook.template_id && notebook.template_id.stages) {
    await notebook.updateProgress(notebook.template_id.stages);
    console.log(`ğŸ“Š Progress updated: ${notebook.progress}%`);
    console.log(
      `ğŸ“‹ Completed tasks in current stage: ${
        currentStageTracking?.completed_tasks?.length || 0
      }`
    );
  }

  if (currentStageTracking) {
    const todayDate = getVietnamToday();
    const today = todayDate.toISOString().split("T")[0];

    console.log(
      `ğŸ” Checking daily_logs for stage ${notebook.current_stage} on ${today}`
    );

    let dailyLog = currentStageTracking.daily_logs?.find(
      (log) => log.date?.toISOString().split("T")[0] === today
    );

    if (!dailyLog) {
      if (!currentStageTracking.daily_logs) {
        currentStageTracking.daily_logs = [];
      }
      dailyLog = {
        date: todayDate,
        daily_progress: 0,
      };
      currentStageTracking.daily_logs.push(dailyLog);
      console.log(`â• Created new daily_log for ${today}`);
    } else {
      console.log(
        `âœ… Found existing daily_log for ${today}: ${dailyLog.daily_progress}%`
      );
    }

    const todayTasks = notebook.daily_checklist || [];
    const completedTodayTasks = todayTasks.filter((t) => t.is_completed).length;
    const totalTodayTasks = todayTasks.length;

    if (totalTodayTasks > 0) {
      dailyLog.daily_progress = Math.round(
        (completedTodayTasks / totalTodayTasks) * 100
      );
      console.log(
        `ğŸ“… Daily progress for ${today}: ${dailyLog.daily_progress}% (${completedTodayTasks}/${totalTodayTasks})`
      );
    }
  } else {
    console.warn(
      `âš ï¸ No currentStageTracking found for stage ${notebook.current_stage}`
    );
  }

  if (currentStageTracking && notebook.template_id) {
    const stageCompletion = await notebook.getCurrentStageCompletion();
    console.log(`ğŸ¯ Current stage completion: ${stageCompletion}%`);

    if (stageCompletion >= 100 && !currentStageTracking.completed_at) {
      currentStageTracking.completed_at = new Date();
      console.log(`âœ… Stage ${notebook.current_stage} marked as COMPLETED`);

      await notebook.updateProgress(notebook.template_id.stages);
      console.log(`ğŸŒ± Plant progress updated: ${notebook.progress}%`);
    }
  }

  await notebook.save();

  return notebook;
};

/**
 * Láº¥y táº¥t cáº£ observations cá»§a stage hiá»‡n táº¡i
 * CHá»ˆ tráº£ vá» observations náº¿u Ä‘ang á»Ÿ ngÃ y cuá»‘i cá»§a giai Ä‘oáº¡n
 */
const getCurrentStageObservations = async (notebookId) => {
  const notebook = await Notebook.findById(notebookId).populate("template_id");

  if (!notebook || !notebook.template_id) {
    return [];
  }

  const template = notebook.template_id;
  const currentStage = template.stages.find(
    (s) => s.stage_number === notebook.current_stage
  );

  if (!currentStage) {
    return [];
  }

  // Kiá»ƒm tra xem cÃ³ pháº£i ngÃ y cuá»‘i cá»§a giai Ä‘oáº¡n khÃ´ng
  const currentDay = notebook.current_day || 1;
  const isLastDayOfStage = currentDay === currentStage.day_end;

  // Náº¿u stage Ä‘Ã£ completed thÃ¬ khÃ´ng tráº£ vá» observation required ná»¯a
  const stageTracking = notebook.stages_tracking.find(
    (s) => s.stage_number === notebook.current_stage
  );
  if (stageTracking && stageTracking.status === "completed") {
    // Tráº£ vá» danh sÃ¡ch observation Ä‘Ã£ ghi nháº­n (cÃ³ value=true)
    return (
      stageTracking.observations?.map((obs) => ({
        key: obs.key,
        value: obs.value,
        observed_at: obs.observed_at,
        completed: true,
      })) || []
    );
  }
  // CHá»ˆ tráº£ vá» observations náº¿u Ä‘ang á»Ÿ ngÃ y cuá»‘i
  if (!isLastDayOfStage) {
    return [];
  }
  // Tráº£ vá» danh sÃ¡ch observation required, kÃ¨m tráº¡ng thÃ¡i Ä‘Ã£ hoÃ n thÃ nh náº¿u cÃ³
  return (currentStage?.observation_required || []).map((obsReq) => {
    const found = stageTracking?.observations?.find(
      (o) => o.key === obsReq.key
    );
    return {
      ...obsReq,
      value: found?.value ?? false,
      observed_at: found?.observed_at ?? null,
      completed: !!found?.value,
    };
  });
};

/**
 * Cáº­p nháº­t observation cho stage hiá»‡n táº¡i
 */
export const updateStageObservation = async (
  notebookId,
  observationKey,
  value
) => {
  const notebook = await Notebook.findById(notebookId).populate("template_id");

  if (!notebook) {
    throw new AppError("KhÃ´ng tÃ¬m tháº¥y nháº­t kÃ½", 404);
  }

  const stageTracking = notebook.stages_tracking.find(
    (s) => s.stage_number === notebook.current_stage
  );

  if (!stageTracking) {
    throw new AppError("KhÃ´ng tÃ¬m tháº¥y stage tracking", 404);
  }

  const existingObs = stageTracking.observations.find(
    (o) => o.key === observationKey
  );

  if (existingObs) {
    existingObs.value = value;
    existingObs.observed_at = new Date();
  } else {
    stageTracking.observations.push({
      key: observationKey,
      value: value,
      observed_at: new Date(),
    });
  }

  await notebook.save();

  // âœ… Kiá»ƒm tra xem táº¥t cáº£ observations Ä‘Ã£ hoÃ n thÃ nh chÆ°a
  if (notebook.template_id && notebook.template_id.stages) {
    const currentTemplateStage = notebook.template_id.stages.find(
      (s) => s.stage_number === notebook.current_stage
    );

    if (currentTemplateStage && currentTemplateStage.observation_required) {
      const requiredObservations = currentTemplateStage.observation_required;
      const completedObservations = stageTracking.observations.filter(
        (obs) => obs.value === true
      );

      console.log(
        `ğŸ“Š Observations: ${completedObservations.length}/${requiredObservations.length} completed`
      );

      // Náº¿u táº¥t cáº£ observations báº¯t buá»™c Ä‘Ã£ hoÃ n thÃ nh (value = true)
      if (completedObservations.length >= requiredObservations.length) {
        console.log(
          `âœ… All observations completed for stage ${notebook.current_stage}`
        );

        // ÄÃ¡nh dáº¥u stage hiá»‡n táº¡i hoÃ n thÃ nh
        stageTracking.completed_at = new Date();
        stageTracking.status = "completed";

        // Cáº­p nháº­t progress
        await notebook.updateProgress(notebook.template_id.stages);

        // Chuyá»ƒn sang stage tiáº¿p theo náº¿u cÃ³
        const nextStageNumber = notebook.current_stage + 1;
        if (nextStageNumber <= notebook.template_id.stages.length) {
          console.log(`ğŸ”„ Auto-switching to stage ${nextStageNumber}`);

          // Táº¯t current flag cá»§a stage hiá»‡n táº¡i
          stageTracking.is_current = false;

          // Báº­t current flag cho stage tiáº¿p theo
          const nextStageTracking = notebook.stages_tracking.find(
            (s) => s.stage_number === nextStageNumber
          );

          if (nextStageTracking) {
            nextStageTracking.is_current = true;
            nextStageTracking.started_at = new Date();
            nextStageTracking.status = "active";
          }

          // Cáº­p nháº­t current_stage
          notebook.current_stage = nextStageNumber;

          // KhÃ´ng táº¡o checklist ngay, chá»‰ táº¡o khi sang ngÃ y má»›i
          notebook.daily_checklist = [];
          await notebook.save();

          console.log(
            `âœ… Stage switched to ${nextStageNumber} successfully (checklist will be generated on next day)`
          );
        } else {
          console.log(`ğŸ All stages completed!`);
          await notebook.save();
        }
      } else {
        await notebook.save();
      }
    } else {
      await notebook.save();
    }
  }

  return notebook;
};

/**
 * TÃ­nh stage hiá»‡n táº¡i dá»±a trÃªn sá»‘ ngÃ y Ä‘Ã£ trá»“ng
 */
const calculateCurrentStage = async (notebookId) => {
  const notebook = await Notebook.findById(notebookId).populate("template_id");

  if (!notebook || !notebook.template_id) {
    return null;
  }

  const template = notebook.template_id;
  const daysPlanted = notebook.current_day;

  const stageInfo = template.getStageByDay(daysPlanted);

  if (stageInfo && stageInfo.stage_number !== notebook.current_stage) {
    await updateCurrentStage(notebookId, stageInfo.stage_number);
  }

  return stageInfo;
};

// ==========================================
// CONTROLLER EXPORTS
// ==========================================

// ğŸ“˜ Láº¥y táº¥t cáº£ notebook cá»§a user
export const getAllByUser = asyncHandler(async (req, res) => {
  const notebooks = await Notebook.find({
    user_id: req.user.id,
    status: { $ne: "deleted" },
  })
    .populate("guide_id", "title category difficulty estimatedTime")
    .populate("template_id", "template_name plant_group status stages")
    .sort({ createdAt: -1 });

  return ok(
    res,
    notebooks,
    { count: notebooks.length },
    "Fetched all notebooks successfully"
  );
});

// ğŸ“— Láº¥y chi tiáº¿t notebook theo ID
export const getNotebookById = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const notebook = await Notebook.findOne({
    _id: id,
    user_id: req.user.id,
    status: { $ne: "deleted" },
  })
    .populate(
      "guide_id",
      "title category difficulty estimatedTime description steps"
    )
    .populate("template_id");

  if (!notebook) {
    return res
      .status(404)
      .json({ success: false, message: "Notebook not found" });
  }

  // ThÃªm stage_completion % vÃ o response (now async)
  const notebookData = notebook.toObject();
  notebookData.stage_completion = await notebook.getCurrentStageCompletion();

  return ok(res, notebookData, null, "Fetched notebook detail successfully");
});

// ğŸ“ Táº¡o má»›i notebook
export const createNotebook = asyncHandler(async (req, res) => {
  const { notebook_name, guide_id, description, cover_image, planted_date } =
    req.body;

  let plant_type = req.body.plant_type;
  let plant_group = null;
  let autoFoundTemplate = null;

  // âœ… FLOW Tá»° Äá»˜NG: Guide â†’ plant_group â†’ Template
  if (guide_id) {
    const guide = await Guide.findById(guide_id);
    if (!guide) {
      return res
        .status(404)
        .json({ success: false, message: "Guide not found" });
    }

    // Láº¥y plant_name vÃ  plant_group tá»« Guide
    plant_type = guide.plant_name || guide.title;
    plant_group = guide.plant_group;

    console.log(`ğŸ“— Guide found: ${guide.plant_name} â†’ Group: ${plant_group}`);

    // Tá»± Ä‘á»™ng tÃ¬m template dá»±a trÃªn plant_group
    if (plant_group && plant_group !== "other") {
      autoFoundTemplate = await PlantTemplate.findOne({
        plant_group: plant_group,
        status: "active",
      }).sort({ usage_count: -1 }); // Láº¥y template Ä‘Æ°á»£c dÃ¹ng nhiá»u nháº¥t

      if (autoFoundTemplate) {
        console.log(
          `âœ… Auto-found template: ${autoFoundTemplate.template_name}`
        );
      } else {
        console.log(`âš ï¸ No active template found for group: ${plant_group}`);
      }
    }
  }

  if (!plant_type) {
    return res.status(400).json({
      success: false,
      message:
        "plant_type is required. Provide either guide_id or plant_type directly.",
    });
  }

  // Táº¡o notebook vá»›i plant_group
  const newNotebook = await Notebook.create({
    user_id: req.user.id,
    notebook_name,
    guide_id: guide_id || undefined,
    plant_type,
    plant_group: plant_group || "other",
    description,
    cover_image,
    planted_date: planted_date || new Date(),
  });

  // âœ… Tá»° Äá»˜NG GÃN TEMPLATE náº¿u tÃ¬m Ä‘Æ°á»£c
  if (autoFoundTemplate) {
    try {
      const notebookWithTemplate = await assignTemplateToNotebook(
        newNotebook._id,
        autoFoundTemplate._id
      );

      console.log(
        `ğŸ‰ Template assigned successfully to notebook ${newNotebook._id}`
      );

      return created(
        res,
        notebookWithTemplate,
        `Notebook created with template: ${autoFoundTemplate.template_name}`
      );
    } catch (error) {
      console.error("âŒ Error assigning template:", error);
      // Váº«n tráº£ vá» notebook Ä‘Ã£ táº¡o, chá»‰ khÃ´ng cÃ³ template
      return created(
        res,
        newNotebook,
        "Notebook created but template assignment failed"
      );
    }
  }

  // KhÃ´ng tÃ¬m Ä‘Æ°á»£c template â†’ tráº£ vá» notebook thÆ°á»ng
  return created(
    res,
    newNotebook,
    "Notebook created successfully (no template found)"
  );
});

// ğŸ”„ Cáº­p nháº­t notebook
export const updateNotebook = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const notebook = await Notebook.findOneAndUpdate(
    { _id: id, user_id: req.user.id },
    req.body,
    { new: true }
  );

  if (!notebook) {
    return res
      .status(404)
      .json({ success: false, message: "Notebook not found" });
  }

  return ok(res, notebook, null, "Notebook updated successfully");
});

// ğŸ—‘ï¸ XÃ³a má»m notebook (soft delete - Ä‘Ã¡nh dáº¥u deleted)
export const deleteNotebook = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const notebook = await Notebook.findOneAndUpdate(
    { _id: id, user_id: req.user.id },
    { status: "deleted", deletedAt: new Date() },
    { new: true }
  );

  if (!notebook) {
    return res
      .status(404)
      .json({ success: false, message: "Notebook not found" });
  }

  return ok(
    res,
    { id: notebook._id, status: notebook.status },
    null,
    "Notebook deleted successfully"
  );
});

// â™»ï¸ KhÃ´i phá»¥c notebook Ä‘Ã£ xÃ³a
export const restoreNotebook = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const notebook = await Notebook.findOneAndUpdate(
    { _id: id, user_id: req.user.id, status: "deleted" },
    { status: "active", $unset: { deletedAt: "" } },
    { new: true }
  );

  if (!notebook) {
    return res
      .status(404)
      .json({ success: false, message: "Notebook not found or not deleted" });
  }

  return ok(
    res,
    { id: notebook._id, status: notebook.status },
    null,
    "Notebook restored successfully"
  );
});

// ğŸ—‘ï¸ Láº¥y danh sÃ¡ch notebook Ä‘Ã£ xÃ³a
export const getDeletedNotebooks = asyncHandler(async (req, res) => {
  const notebooks = await Notebook.find({
    user_id: req.user.id,
    status: "deleted",
  })
    .populate("guide_id", "title category")
    .populate("template_id", "template_name plant_group")
    .sort({ deletedAt: -1 });

  return ok(
    res,
    notebooks,
    { count: notebooks.length },
    "Deleted notebooks fetched successfully"
  );
});

// ğŸ’€ XÃ³a vÄ©nh viá»…n notebook (hard delete)
export const permanentDeleteNotebook = asyncHandler(async (req, res) => {
  const { id } = req.params;

  const notebook = await Notebook.findOneAndDelete({
    _id: id,
    user_id: req.user.id,
    status: "deleted", // Chá»‰ cho phÃ©p xÃ³a vÄ©nh viá»…n notebook Ä‘Ã£ á»Ÿ tráº¡ng thÃ¡i deleted
  });

  if (!notebook) {
    return res.status(404).json({
      success: false,
      message: "Notebook not found or not in deleted status",
    });
  }

  return ok(res, { id: notebook._id }, null, "Notebook permanently deleted");
});

// ğŸ” TÃ¬m kiáº¿m notebook theo tá»« khÃ³a
export const searchNotebooks = asyncHandler(async (req, res) => {
  const { keyword } = req.query;

  if (!keyword) {
    return res
      .status(400)
      .json({ success: false, message: "Keyword is required" });
  }

  const notebooks = await Notebook.find({
    user_id: req.user.id,
    status: { $ne: "deleted" },
    $or: [
      { notebook_name: { $regex: keyword, $options: "i" } },
      { plant_type: { $regex: keyword, $options: "i" } },
      { description: { $regex: keyword, $options: "i" } },
    ],
  })
    .populate("guide_id", "title category difficulty")
    .populate("template_id", "template_name plant_group")
    .sort({ createdAt: -1 });

  const meta = { count: notebooks.length, keyword };
  return ok(res, notebooks, meta, "Search results fetched successfully");
});

// ğŸ§© Lá»c notebook theo tiÃªu chÃ­
export const filterNotebooks = asyncHandler(async (req, res) => {
  const { plant_type, status, min_progress, max_progress, sort_by, order } =
    req.query;

  const filter = {
    user_id: req.user.id,
    status: { $ne: "deleted" },
  };

  if (plant_type) filter.plant_type = { $regex: plant_type, $options: "i" };
  if (status && ["active", "archived"].includes(status)) filter.status = status;
  if (min_progress !== undefined || max_progress !== undefined) {
    filter.progress = {};
    if (min_progress !== undefined)
      filter.progress.$gte = parseInt(min_progress);
    if (max_progress !== undefined)
      filter.progress.$lte = parseInt(max_progress);
  }

  let sortOption = { createdAt: -1 };
  if (sort_by) {
    const sortOrder = order === "asc" ? 1 : -1;
    switch (sort_by) {
      case "name":
        sortOption = { notebook_name: sortOrder };
        break;
      case "progress":
        sortOption = { progress: sortOrder };
        break;
      case "created":
        sortOption = { createdAt: sortOrder };
        break;
      case "updated":
        sortOption = { updatedAt: sortOrder };
        break;
    }
  }

  const notebooks = await Notebook.find(filter)
    .populate("guide_id", "title category difficulty estimatedTime")
    .populate("template_id", "template_name plant_group status")
    .sort(sortOption);

  const meta = {
    count: notebooks.length,
    filter: {
      plant_type: plant_type || "all",
      status: status || "all except deleted",
      progress_range: { min: min_progress || 0, max: max_progress || 100 },
      sort_by: sort_by || "created",
      order: order || "desc",
    },
  };

  return ok(res, notebooks, meta, "Filtered notebooks fetched successfully");
});

// ğŸ–¼ï¸ ThÃªm áº£nh vÃ o notebook
export const addImage = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { image_url } = req.body;

  if (!image_url) {
    return res
      .status(400)
      .json({ success: false, message: "image_url is required" });
  }

  const notebook = await Notebook.findOne({
    _id: id,
    user_id: req.user.id,
    status: { $ne: "deleted" },
  });

  if (!notebook) {
    return res
      .status(404)
      .json({ success: false, message: "Notebook not found" });
  }

  notebook.images.push(image_url);
  await notebook.save();

  return ok(
    res,
    { images: notebook.images, total: notebook.images.length },
    null,
    "Image added successfully"
  );
});

// ğŸ§¹ XÃ³a áº£nh khá»i notebook
export const removeImage = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { image_url } = req.body;

  if (!image_url) {
    return res
      .status(400)
      .json({ success: false, message: "image_url is required" });
  }

  const notebook = await Notebook.findOne({
    _id: id,
    user_id: req.user.id,
    status: { $ne: "deleted" },
  });

  if (!notebook) {
    return res
      .status(404)
      .json({ success: false, message: "Notebook not found" });
  }

  notebook.images = notebook.images.filter((img) => img !== image_url);
  await notebook.save();

  return ok(
    res,
    { images: notebook.images, total: notebook.images.length },
    null,
    "Image removed successfully"
  );
});

// ğŸŒ± Láº¥y template phÃ¹ há»£p cho notebook
export const getNotebookTemplate = asyncHandler(async (req, res) => {
  const { id } = req.params;

  const template = await getTemplateForNotebook(id);

  if (!template) {
    return res
      .status(404)
      .json({ success: false, message: "No suitable template found" });
  }

  return ok(res, template, null, "Template fetched successfully");
});

// ğŸ“Œ GÃ¡n template cho notebook
export const assignTemplate = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { template_id } = req.body;

  if (!template_id) {
    return res
      .status(400)
      .json({ success: false, message: "template_id is required" });
  }

  const notebook = await assignTemplateToNotebook(id, template_id);

  return ok(res, notebook, null, "Template assigned successfully");
});

// ğŸ“Š Láº¥y timeline cá»§a notebook
export const getNotebookTimeline = asyncHandler(async (req, res) => {
  const { id } = req.params;

  // Validate ID
  if (!id || id === "undefined" || id === "null") {
    return res.status(400).json({
      success: false,
      message: "Invalid notebook ID",
    });
  }

  const notebook = await Notebook.findById(id).populate("template_id");

  if (!notebook || !notebook.template_id) {
    return ok(
      res,
      null,
      { hasTemplate: false },
      "Notebook chÆ°a cÃ³ template. Vui lÃ²ng gÃ¡n template Ä‘á»ƒ xem timeline."
    );
  }

  const template = notebook.template_id;

  const timeline = notebook.stages_tracking.map((tracking) => {
    const templateStage = template.stages.find(
      (s) => s.stage_number === tracking.stage_number
    );

    return {
      stage_number: tracking.stage_number,
      stage_name: tracking.stage_name,
      started_at: tracking.started_at,
      completed_at: tracking.completed_at,
      is_current: tracking.is_current,
      duration_days: templateStage
        ? templateStage.day_end - templateStage.day_start + 1
        : null,
      start_day: templateStage ? templateStage.day_start : null,
      end_day: templateStage ? templateStage.day_end : null,
      observations: tracking.observations,
    };
  });

  const timelineData = {
    planted_date: notebook.planted_date,
    current_day: notebook.current_day,
    progress: notebook.progress,
    total_days: template.total_days,
    timeline,
  };

  return ok(res, timelineData, null, "Timeline fetched successfully");
});

// âœ… Láº¥y daily checklist
export const getDailyChecklist = asyncHandler(async (req, res) => {
  const { id } = req.params;

  // Validate ID
  if (!id || id === "undefined" || id === "null") {
    return res.status(400).json({
      success: false,
      message: "Invalid notebook ID",
    });
  }

  const checklist = await generateDailyChecklist(id);

  // âœ… Return 200 with empty array instead of 404 for better UX
  if (!checklist) {
    return ok(
      res,
      [],
      { hasTemplate: false },
      "Notebook chÆ°a cÃ³ template. Vui lÃ²ng gÃ¡n template Ä‘á»ƒ táº¡o checklist."
    );
  }

  return ok(res, checklist, null, "Daily checklist fetched successfully");
});

// âœ”ï¸ ÄÃ¡nh dáº¥u hoÃ n thÃ nh task
export const completeTask = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { task_name } = req.body;

  if (!task_name) {
    return res
      .status(400)
      .json({ success: false, message: "task_name is required" });
  }

  const notebook = await completeChecklistTask(id, task_name);

  return ok(res, notebook.daily_checklist, null, "Task completed successfully");
});

// ğŸ”„ Cáº­p nháº­t stage hiá»‡n táº¡i
export const updateStage = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { stage_number } = req.body;

  if (!stage_number) {
    return res
      .status(400)
      .json({ success: false, message: "stage_number is required" });
  }

  const notebook = await updateCurrentStage(id, stage_number);

  return ok(res, notebook, null, "Stage updated successfully");
});

// ğŸ‘ï¸ Láº¥y observations cá»§a stage hiá»‡n táº¡i
export const getCurrentObservations = asyncHandler(async (req, res) => {
  const { id } = req.params;

  const observations = await getCurrentStageObservations(id);

  return ok(
    res,
    observations,
    null,
    "Current stage observations fetched successfully"
  );
});

// ğŸ“ Cáº­p nháº­t observation
export const updateObservation = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { observation_key, value } = req.body;

  if (!observation_key || value === undefined) {
    return res.status(400).json({
      success: false,
      message: "observation_key and value are required",
    });
  }

  const notebook = await updateStageObservation(id, observation_key, value);

  // Kiá»ƒm tra xem cÃ³ chuyá»ƒn stage khÃ´ng
  const currentStage = notebook.stages_tracking.find((s) => s.is_current);
  const previousStageNumber = req.body._previousStage || notebook.current_stage;

  if (currentStage && currentStage.stage_number > previousStageNumber) {
    return ok(
      res,
      notebook,
      {
        auto_transitioned: true,
        new_stage: currentStage.stage_number,
        stage_name: currentStage.stage_name,
      },
      `âœ… ÄÃ£ hoÃ n thÃ nh táº¥t cáº£ Ä‘iá»u kiá»‡n quan sÃ¡t! Tá»± Ä‘á»™ng chuyá»ƒn sang ${currentStage.stage_name}.`
    );
  }

  return ok(res, notebook, null, "Observation updated successfully");
});

// ğŸ” TÃ­nh stage hiá»‡n táº¡i dá»±a trÃªn sá»‘ ngÃ y
export const calculateStage = asyncHandler(async (req, res) => {
  const { id } = req.params;

  const stageInfo = await calculateCurrentStage(id);

  if (!stageInfo) {
    return res
      .status(404)
      .json({ success: false, message: "Cannot calculate stage" });
  }

  return ok(res, stageInfo, null, "Stage calculated successfully");
});

// ğŸ”„ Recalculate progress (debug endpoint)
export const recalculateProgress = asyncHandler(async (req, res) => {
  const { id } = req.params;

  const notebook = await Notebook.findOne({
    _id: id,
    user_id: req.user.id,
  }).populate("template_id");

  if (!notebook || !notebook.template_id) {
    return res.status(404).json({
      success: false,
      message: "Notebook not found or no template assigned",
    });
  }

  // Recalculate progress
  await notebook.updateProgress(notebook.template_id.stages);
  await notebook.save();

  const stageCompletion = await notebook.getCurrentStageCompletion();

  return ok(
    res,
    {
      progress: notebook.progress,
      stage_completion: stageCompletion,
      template_stages: notebook.template_id.stages.map((s) => ({
        stage_number: s.stage_number,
        name: s.name,
        weight:
          s.weight || Math.round(100 / notebook.template_id.stages.length),
      })),
      stages_tracking: notebook.stages_tracking.map((s) => ({
        stage_number: s.stage_number,
        stage_name: s.stage_name,
        is_current: s.is_current,
        completed: !!s.completed_at,
      })),
    },
    null,
    "Progress recalculated successfully"
  );
});

// ğŸ”§ Migrate old notebooks to add completed_tasks field
export const migrateNotebooks = asyncHandler(async (req, res) => {
  const notebooks = await Notebook.find({
    user_id: req.user.id,
  }).populate("template_id");

  let migratedCount = 0;

  for (const notebook of notebooks) {
    let needsSave = false;

    // Check each stage_tracking
    for (const stageTracking of notebook.stages_tracking) {
      // If no completed_tasks, initialize empty array
      if (!stageTracking.completed_tasks) {
        stageTracking.completed_tasks = [];
        needsSave = true;
      }
    }

    if (needsSave) {
      await notebook.save();
      migratedCount++;
      console.log(
        `âœ… Migrated notebook: ${notebook.notebook_name} (${notebook._id})`
      );
    }
  }

  return ok(
    res,
    {
      total: notebooks.length,
      migrated: migratedCount,
      already_updated: notebooks.length - migratedCount,
    },
    null,
    `Migration complete! ${migratedCount} notebook(s) updated`
  );
});

// ==========================================
// STAGE MONITORING EXPORTS
// ==========================================

// ğŸ” Kiá»ƒm tra má»™t notebook cá»¥ thá»ƒ (manual trigger)
export const checkSingleNotebook = asyncHandler(async (req, res) => {
  const { id } = req.params;

  const notebook = await Notebook.findById(id).populate("template_id");

  if (!notebook) {
    return res.status(404).json({
      success: false,
      message: "KhÃ´ng tÃ¬m tháº¥y notebook",
    });
  }

  await checkNotebookStageStatus(notebook);

  return ok(
    res,
    {
      notebook_id: notebook._id,
      notebook_name: notebook.notebook_name,
      current_stage: notebook.current_stage,
      stages_tracking: notebook.stages_tracking.map((s) => ({
        stage_number: s.stage_number,
        stage_name: s.stage_name,
        status: s.status,
        missed_days: s.missed_days,
        is_current: s.is_current,
      })),
    },
    null,
    "Notebook stage status checked successfully"
  );
});

// ğŸ”„ Monitor táº¥t cáº£ notebooks (admin/cron endpoint)
export const monitorAllNotebooks = asyncHandler(async (req, res) => {
  console.log("ğŸ” Báº¯t Ä‘áº§u monitor táº¥t cáº£ notebooks...");

  try {
    const notebooks = await Notebook.find({
      status: "active",
      template_id: { $exists: true, $ne: null },
    }).populate("template_id");

    console.log(`ğŸ“Š TÃ¬m tháº¥y ${notebooks.length} notebooks cáº§n kiá»ƒm tra`);

    for (const notebook of notebooks) {
      await checkNotebookStageStatus(notebook);
    }

    console.log("âœ… HoÃ n thÃ nh monitor táº¥t cáº£ notebooks");

    return ok(
      res,
      {
        total_checked: notebooks.length,
        timestamp: new Date(),
      },
      null,
      "All notebooks monitored successfully"
    );
  } catch (error) {
    console.error("âŒ Lá»—i khi monitor notebooks:", error);
    return res.status(500).json({
      success: false,
      message: "Error monitoring notebooks",
      error: error.message,
    });
  }
});

// ==========================================
// DAILY STATUS & OVERDUE MANAGEMENT
// ==========================================

// ğŸ“… Láº¥y tráº¡ng thÃ¡i hÃ ng ngÃ y (tasks hÃ´m nay + overdue summary)
export const getDailyStatus = asyncHandler(async (req, res) => {
  const { id } = req.params; // notebook_id

  const notebook = await Notebook.findOne({
    _id: id,
    user_id: req.user.id,
    status: { $ne: "deleted" },
  }).populate("template_id");

  if (!notebook) {
    return res.status(404).json({
      success: false,
      message: "Notebook not found",
    });
  }

  console.log(
    `ğŸ”” getDailyStatus called for notebook=${id} user=${req.user?.id}`
  );

  // Táº¡o checklist cho hÃ´m nay (sáº½ tá»± Ä‘á»™ng xá»­ lÃ½ overdue náº¿u sang ngÃ y má»›i)
  await generateDailyChecklist(id);

  // Reload notebook sau khi generate
  const updatedNotebook = await Notebook.findById(id).populate("template_id");

  const currentStageTracking = updatedNotebook.stages_tracking.find(
    (s) => s.stage_number === updatedNotebook.current_stage
  );

  const today = getVietnamToday();
  const overdueSummary = currentStageTracking?.overdue_summary?.ready_to_notify
    ? {
        overdue_date: currentStageTracking.overdue_summary.date,
        overdue_count: currentStageTracking.overdue_summary.overdue_count,
      }
    : null;

  return ok(
    res,
    {
      today: today.toISOString().split("T")[0],
      current_day: updatedNotebook.current_day,
      tasks_today: updatedNotebook.daily_checklist,
      overdue_summary: overdueSummary,
    },
    null,
    "Daily status fetched successfully"
  );
});

// ğŸ—‘ï¸ Bá» qua táº¥t cáº£ overdue tasks
export const skipOverdueTasks = asyncHandler(async (req, res) => {
  const { id } = req.params; // notebook_id

  const notebook = await Notebook.findOne({
    _id: id,
    user_id: req.user.id,
    status: { $ne: "deleted" },
  });

  if (!notebook) {
    return res.status(404).json({
      success: false,
      message: "Notebook not found",
    });
  }

  // ÄÃ¡nh dáº¥u táº¥t cáº£ overdue tasks (Ä‘Æ°á»£c lÆ°u trong stageTracking.overdue_tasks) = skipped
  const currentStageTracking = notebook.stages_tracking.find(
    (s) => s.stage_number === notebook.current_stage
  );

  if (!currentStageTracking || !currentStageTracking.overdue_tasks) {
    return ok(res, null, null, "No overdue tasks to skip");
  }

  const overdueTasks = currentStageTracking.overdue_tasks.filter(
    (t) => t.status === "overdue"
  );

  if (overdueTasks.length === 0) {
    return ok(res, null, null, "No overdue tasks to skip");
  }

  overdueTasks.forEach((t) => {
    t.status = "skipped";
    t.skipped_at = new Date();
  });

  // Reset overdue_summary notify flag
  if (currentStageTracking && currentStageTracking.overdue_summary) {
    currentStageTracking.overdue_summary.ready_to_notify = false;
    currentStageTracking.overdue_summary.notified_at = new Date();
  }

  await notebook.save();

  return ok(
    res,
    { skipped_count: overdueTasks.length },
    null,
    `${overdueTasks.length} overdue tasks skipped successfully`
  );
});

// âœ… HoÃ n thÃ nh má»™t overdue task (hoÃ n thÃ nh bÃ¹)
export const completeOverdueTask = asyncHandler(async (req, res) => {
  const { id } = req.params; // notebook_id
  const { task_name } = req.body;

  if (!task_name) {
    return res
      .status(400)
      .json({ success: false, message: "task_name is required" });
  }

  const notebook = await Notebook.findOne({
    _id: id,
    user_id: req.user.id,
    status: { $ne: "deleted" },
  }).populate("template_id");

  if (!notebook) {
    return res
      .status(404)
      .json({ success: false, message: "Notebook not found" });
  }

  const currentStageTracking = notebook.stages_tracking.find(
    (s) => s.stage_number === notebook.current_stage
  );

  if (!currentStageTracking || !currentStageTracking.overdue_tasks) {
    return res
      .status(404)
      .json({ success: false, message: "No overdue tasks found" });
  }

  const task = currentStageTracking.overdue_tasks.find(
    (t) => t.task_name === task_name && t.status === "overdue"
  );

  if (!task) {
    return res
      .status(404)
      .json({ success: false, message: "Overdue task not found" });
  }

  // Mark as completed
  task.is_completed = true;
  task.completed_at = new Date();
  task.status = "completed";

  // Add to completed_tasks for tracking (if not already)
  if (!currentStageTracking.completed_tasks) {
    currentStageTracking.completed_tasks = [];
  }
  const alreadyCompleted = currentStageTracking.completed_tasks.some(
    (t) => t.task_name === task_name
  );
  if (!alreadyCompleted) {
    currentStageTracking.completed_tasks.push({
      task_name,
      completed_at: new Date(),
    });
  }

  // Update today's daily_log progress to include this makeup completion
  const todayDate = getVietnamToday();
  const today = todayDate.toISOString().split("T")[0];

  if (!currentStageTracking.daily_logs) {
    currentStageTracking.daily_logs = [];
  }

  let dailyLog = currentStageTracking.daily_logs.find(
    (log) => log.date?.toISOString().split("T")[0] === today
  );

  if (!dailyLog) {
    dailyLog = { date: todayDate, daily_progress: 0 };
    currentStageTracking.daily_logs.push(dailyLog);
  }

  // Compute new daily progress: existing completed today + this makeup / total today tasks
  const todayTasks = notebook.daily_checklist || [];
  const completedTodayTasks = todayTasks.filter((t) => t.is_completed).length;
  const totalTodayTasks = todayTasks.length || 0;

  if (totalTodayTasks > 0) {
    const newProgress = Math.min(
      100,
      Math.round(((completedTodayTasks + 1) / totalTodayTasks) * 100)
    );
    dailyLog.daily_progress = newProgress;
  } else {
    // If no daily tasks today, conservatively set a small progress increment (e.g., 10%)
    dailyLog.daily_progress = Math.min(
      100,
      (dailyLog.daily_progress || 0) + 10
    );
  }

  // Recalculate overall progress
  if (notebook.template_id && notebook.template_id.stages) {
    await notebook.updateProgress(notebook.template_id.stages);
    console.log(
      `ğŸ“Š Progress updated after completing overdue task: ${notebook.progress}%`
    );
  }
  // Recompute overdue_summary count and notify flag
  const remainingOverdue = currentStageTracking.overdue_tasks.filter(
    (t) => t.status === "overdue"
  ).length;

  if (!currentStageTracking.overdue_summary) {
    currentStageTracking.overdue_summary = {
      date: null,
      overdue_count: 0,
      ready_to_notify: false,
    };
  }

  currentStageTracking.overdue_summary.overdue_count = remainingOverdue;
  if (remainingOverdue === 0) {
    currentStageTracking.overdue_summary.ready_to_notify = false;
    currentStageTracking.overdue_summary.notified_at = new Date();
  }

  await notebook.save();

  return ok(
    res,
    {
      notebook_id: notebook._id,
      stage_completion: notebook.stage_completion,
      progress: notebook.progress,
    },
    null,
    "Overdue task completed successfully"
  );
});

// ğŸ“‹ Láº¥y chi tiáº¿t overdue tasks
export const getOverdueDetail = asyncHandler(async (req, res) => {
  const { id } = req.params; // notebook_id

  const notebook = await Notebook.findOne({
    _id: id,
    user_id: req.user.id,
    status: { $ne: "deleted" },
  });

  if (!notebook) {
    return res.status(404).json({
      success: false,
      message: "Notebook not found",
    });
  }

  console.log(
    `ğŸ”” getOverdueDetail called for notebook=${id} user=${req.user?.id}`
  );

  const currentStageTracking = notebook.stages_tracking.find(
    (s) => s.stage_number === notebook.current_stage
  );

  const overdueTasks = currentStageTracking?.overdue_tasks || [];

  console.log(
    `ğŸ” Overdue tasks for notebook=${id} stage=${notebook.current_stage}: persisted=${overdueTasks.length}`
  );

  return ok(
    res,
    {
      overdue_date: currentStageTracking?.overdue_summary?.date || null,
      overdue_count: overdueTasks.length,
      overdue_tasks: overdueTasks,
    },
    null,
    "Overdue tasks detail fetched successfully"
  );
});

// =====================
// Notebook statistics
// =====================
export const getStats = asyncHandler(async (req, res) => {
  const userId = req.user?.id;

  const match = { status: { $ne: "deleted" } };
  if (userId) match.user_id = new mongoose.Types.ObjectId(userId);

  // By type
  const byTypeAgg = await Notebook.aggregate([
    { $match: match },
    { $group: { _id: "$plant_type", count: { $sum: 1 } } },
    { $sort: { count: -1 } },
  ]);

  // By group
  const byGroupAgg = await Notebook.aggregate([
    { $match: match },
    { $group: { _id: "$plant_group", count: { $sum: 1 } } },
    { $sort: { count: -1 } },
  ]);

  // Average progress
  const progressAgg = await Notebook.aggregate([
    { $match: match },
    { $group: { _id: null, avgProgress: { $avg: "$progress" } } },
  ]);

  const avgProgress = progressAgg[0]?.avgProgress ?? 0;

  // Progress distribution
  const distributionAgg = await Notebook.aggregate([
    { $match: match },
    {
      $bucket: {
        groupBy: "$progress",
        boundaries: [0, 25, 50, 75, 100, 101],
        default: "unknown",
        output: { count: { $sum: 1 } },
      },
    },
  ]);

  const progressDistribution = {
    "0-25": 0,
    "25-50": 0,
    "50-75": 0,
    "75-100": 0,
  };
  distributionAgg.forEach((b) => {
    const key = b._id;
    if (key === 0) progressDistribution["0-25"] = b.count;
    else if (key === 25) progressDistribution["25-50"] = b.count;
    else if (key === 50) progressDistribution["50-75"] = b.count;
    else if (key === 75) progressDistribution["75-100"] = b.count;
  });

  // Most popular type
  const mostPopularType = byTypeAgg.length > 0 ? byTypeAgg[0]._id : null;

  // Average grow days (planted_date -> max completed_at)
  const avgGrowAgg = await Notebook.aggregate([
    { $match: match },
    {
      $addFields: { maxCompletedAt: { $max: "$stages_tracking.completed_at" } },
    },
    {
      $match: {
        planted_date: { $exists: true, $ne: null },
        maxCompletedAt: { $exists: true, $ne: null },
      },
    },
    {
      $project: {
        diffDays: {
          $divide: [
            { $subtract: ["$maxCompletedAt", "$planted_date"] },
            1000 * 60 * 60 * 24,
          ],
        },
      },
    },
    { $group: { _id: null, avgGrowDays: { $avg: "$diffDays" } } },
  ]);

  const avgGrowDays = avgGrowAgg[0]?.avgGrowDays ?? null;

  const byType = {};
  byTypeAgg.forEach((r) => (byType[r._id || "Unknown"] = r.count));

  const byGroup = {};
  byGroupAgg.forEach((r) => (byGroup[r._id || "unknown"] = r.count));

  const result = {
    byType,
    byGroup,
    mostPopularType,
    progressAvg: Math.round(avgProgress),
    progressDistribution,
    avgGrowDays: avgGrowDays ? Math.round(avgGrowDays) : null,
  };

  return ok(res, result, null, "Notebook statistics fetched successfully");
});
